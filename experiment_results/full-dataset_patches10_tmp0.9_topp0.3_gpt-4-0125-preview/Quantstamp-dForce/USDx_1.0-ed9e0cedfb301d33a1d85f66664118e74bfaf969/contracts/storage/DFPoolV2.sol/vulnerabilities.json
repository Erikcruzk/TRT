{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 322,
          "vulnerability_to_line": null,
          "vulnerability_code": "        owner = msg.sender;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 323,
          "vulnerability_to_line": null,
          "vulnerability_code": "        emit LogSetOwner(msg.sender);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 324,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _dfcol) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 477,
          "vulnerability_to_line": null,
          "vulnerability_code": "        dfcol = _dfcol;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 478,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 559,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 560,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _dfcol,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 561,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _dFPoolOld,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 562,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _dTokenController\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 563,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 564,
          "vulnerability_to_line": null,
          "vulnerability_code": "        initialize(_dfcol, _dFPoolOld, _dTokenController);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 565,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 628,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _tokens.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 194,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require((z = x + y) >= x, \"ds-math-add-overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 197,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 200,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 204,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(y > 0, \"ds-math-div-overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 333,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newOwner_ != owner, \"TransferOwnership: the same owner.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 338,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == newOwner, \"AcceptOwnership: only new owner do this.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 354,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(isOwner(msg.sender), \"ds-auth-non-owner\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 363,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 389,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_address != address(0), \"ValidAddress: address invalid.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 486,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 487,
          "vulnerability_to_line": null,
          "vulnerability_code": "            doTransferFrom(_tokenID, _from, address(this), _amount),\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 488,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"transferFromSender: failed\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 489,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 502,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(doTransferOut(_tokenID, _to, _amount), \"transferOut: failed\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 512,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 513,
          "vulnerability_to_line": null,
          "vulnerability_code": "            dfcol != address(0),\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 514,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"TransferToCol: collateral address empty.\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 515,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 517,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 518,
          "vulnerability_to_line": null,
          "vulnerability_code": "            doTransferOut(_tokenID, dfcol, _amount),\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 519,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"transferToCol: failed\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 520,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 530,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 531,
          "vulnerability_to_line": null,
          "vulnerability_code": "            dfcol != address(0),\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 532,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"TransferFromSenderToCol: collateral address empty.\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 533,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 535,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 536,
          "vulnerability_to_line": null,
          "vulnerability_code": "            doTransferFrom(_tokenID, _from, dfcol, _amount),\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 537,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"transferFromSenderToCol: failed\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 538,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 547,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 548,
          "vulnerability_to_line": null,
          "vulnerability_code": "            doApprove(_tokenIdx, _engineAddress, uint256(-1)),\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 549,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"approveToEngine: Approve failed!\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 550,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 573,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!initialized, \"initialize: Already initialized!\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 648,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 649,
          "vulnerability_to_line": null,
          "vulnerability_code": "                add(_balance, _amount) ==\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 650,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    IERC20(_srcToken).balanceOf(address(this)),\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 651,
          "vulnerability_to_line": null,
          "vulnerability_code": "                \"migrateOldPool: Transfer src token to new pool verification failed\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 652,
          "vulnerability_to_line": null,
          "vulnerability_code": "            );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 664,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 665,
          "vulnerability_to_line": null,
          "vulnerability_code": "                IDSWrappedToken(_tokens[i]).reverseByMultiple(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 666,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    IERC20(_tokens[i]).balanceOf(address(this))\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 667,
          "vulnerability_to_line": null,
          "vulnerability_code": "                ) == IERC20(_srcToken).balanceOf(address(this)),\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 668,
          "vulnerability_to_line": null,
          "vulnerability_code": "                \"migrateOldPool: Pending src token in new pool verification failed\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 669,
          "vulnerability_to_line": null,
          "vulnerability_code": "            );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 682,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_dToken != address(0), \"approve: dToekn address empty.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 683,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 684,
          "vulnerability_to_line": null,
          "vulnerability_code": "            doApprove(_tokenID, _dToken, uint256(-1)),\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 685,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"approve: Approve failed!\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 686,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 275,
          "vulnerability_to_line": null,
          "vulnerability_code": "        else if (base == 0 && exponent != 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return 0;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 277,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 278,
          "vulnerability_to_line": null,
          "vulnerability_code": "        else {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 279,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint256 z = base;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 280,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint256 i = 1; i < exponent; i++)\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 281,
          "vulnerability_to_line": null,
          "vulnerability_code": "                z = mul(z, base);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 282,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return z;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 283,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 280,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint256 i = 1; i < exponent; i++)\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 628,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _tokens.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 333,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newOwner_ != owner, \"TransferOwnership: the same owner.\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 338,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == newOwner, \"AcceptOwnership: only new owner do this.\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 512,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 513,
          "vulnerability_to_line": null,
          "vulnerability_code": "            dfcol != address(0),\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 514,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"TransferToCol: collateral address empty.\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 515,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 530,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 531,
          "vulnerability_to_line": null,
          "vulnerability_code": "            dfcol != address(0),\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 532,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"TransferFromSenderToCol: collateral address empty.\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 533,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 648,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 649,
          "vulnerability_to_line": null,
          "vulnerability_code": "                add(_balance, _amount) ==\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 650,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    IERC20(_srcToken).balanceOf(address(this)),\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 651,
          "vulnerability_to_line": null,
          "vulnerability_code": "                \"migrateOldPool: Transfer src token to new pool verification failed\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 652,
          "vulnerability_to_line": null,
          "vulnerability_code": "            );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 664,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 665,
          "vulnerability_to_line": null,
          "vulnerability_code": "                IDSWrappedToken(_tokens[i]).reverseByMultiple(\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 666,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    IERC20(_tokens[i]).balanceOf(address(this))\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 667,
          "vulnerability_to_line": null,
          "vulnerability_code": "                ) == IERC20(_srcToken).balanceOf(address(this)),\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 668,
          "vulnerability_to_line": null,
          "vulnerability_code": "                \"migrateOldPool: Pending src token in new pool verification failed\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 669,
          "vulnerability_to_line": null,
          "vulnerability_code": "            );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_87"
      ],
      "vulnerability_findings": [
        {
          "name": "erc20-interface",
          "vulnerability_from_line": 9,
          "vulnerability_to_line": 86,
          "vulnerability_code": "interface IERC20 {\n\n    /**\n\n     * @dev Returns the amount of tokens in existence.\n\n     */\n\n    function totalSupply() external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Returns the amount of tokens owned by `account`.\n\n     */\n\n    function balanceOf(address account) external view returns (uint256);\n\n\n\n    /**\n\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n\n     *\n\n     * Emits a {Transfer} event.\n\n     */\n\n    function transfer(address recipient, uint256 amount) external;\n\n\n\n    /**\n\n     * @dev Returns the remaining number of tokens that `spender` will be\n\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n\n     * zero by default.\n\n     *\n\n     * This value changes when {approve} or {transferFrom} are called.\n\n     */\n\n    function allowance(address owner, address spender)\n\n        external\n\n        view\n\n        returns (uint256);\n\n\n\n    /**\n\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n\n     *\n\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n\n     * that someone may use both the old and the new allowance by unfortunate\n\n     * transaction ordering. One possible solution to mitigate this race\n\n     * condition is to first reduce the spender's allowance to 0 and set the\n\n     * desired value afterwards:\n\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\n     *\n\n     * Emits an {Approval} event.\n\n     */\n\n    function approve(address spender, uint256 amount) external;\n\n\n\n    /**\n\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n\n     * allowance mechanism. `amount` is then deducted from the caller's\n\n     * allowance.\n\n     *\n\n     * Emits a {Transfer} event.\n\n     */\n\n    function transferFrom(\n\n        address sender,\n\n        address recipient,\n\n        uint256 amount\n\n    ) external;\n\n\n\n    /**\n\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n\n     * another (`to`).\n\n     *\n\n     * Note that `value` may be zero.\n\n     */\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n\n\n    /**\n\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n\n     * a call to {approve}. `value` is the new allowance.\n\n     */\n\n    event Approval(\n\n        address indexed owner,\n\n        address indexed spender,\n\n        uint256 value\n\n    );\n\n\n\n    // This function is not a standard ERC20 interface, just for compitable with market.\n\n    function decimals() external view returns (uint8);\n",
          "message": "IERC20 (DFPoolV2.sol#9-86) has incorrect ERC20 function interface(s):\n\t-transfer (DFPoolV2.sol#25)\n\t-approve (DFPoolV2.sol#51)\n\t-transferFrom (DFPoolV2.sol#60-64)\n"
        },
        {
          "name": "incorrect-equality",
          "vulnerability_from_line": 618,
          "vulnerability_to_line": 676,
          "vulnerability_code": "    function migrateOldPool(address[] calldata _tokens, address _usdx)\n\n        external\n\n        auth\n\n    {\n\n        address _dFPoolOld = dFPoolOld;\n\n        address _dfcol = dfcol;\n\n        address _dTokenController = dTokenController;\n\n        address _srcToken;\n\n        uint256 _amount;\n\n        uint256 _balance;\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n\n            // transfer pending wrapped token to new pool\n\n            _amount = IERC20(_tokens[i]).balanceOf(_dFPoolOld);\n\n            if (_amount > 0)\n\n                DFPoolV1(_dFPoolOld).transferOut(\n\n                    _tokens[i],\n\n                    address(this),\n\n                    _amount\n\n                );\n\n\n\n            // transfer all src token to new pool\n\n            _srcToken = IDSWrappedToken(_tokens[i]).getSrcERC20();\n\n            _amount = IERC20(_srcToken).balanceOf(_dFPoolOld);\n\n            _balance = IERC20(_srcToken).balanceOf(address(this));\n\n            if (_amount > 0)\n\n                DFPoolV1(_dFPoolOld).transferOut(\n\n                    _srcToken,\n\n                    address(this),\n\n                    _amount\n\n                );\n\n            require(\n\n                add(_balance, _amount) ==\n\n                    IERC20(_srcToken).balanceOf(address(this)),\n\n                \"migrateOldPool: Transfer src token to new pool verification failed\"\n\n            );\n\n\n\n            // mint collateral token into dToken\n\n            _amount = IERC20(_tokens[i]).balanceOf(_dfcol);\n\n            if (_amount > 0)\n\n                IDToken(\n\n                    IDTokenController(_dTokenController).getDToken(_srcToken)\n\n                )\n\n                    .mint(\n\n                    address(this),\n\n                    IDSWrappedToken(_tokens[i]).reverseByMultiple(_amount)\n\n                );\n\n            require(\n\n                IDSWrappedToken(_tokens[i]).reverseByMultiple(\n\n                    IERC20(_tokens[i]).balanceOf(address(this))\n\n                ) == IERC20(_srcToken).balanceOf(address(this)),\n\n                \"migrateOldPool: Pending src token in new pool verification failed\"\n\n            );\n\n        }\n\n\n\n        // transfer claimable USDx to new pool\n\n        _amount = IERC20(_usdx).balanceOf(_dFPoolOld);\n\n        if (_amount > 0)\n\n            DFPoolV1(_dFPoolOld).transferOut(_usdx, address(this), _amount);\n",
          "message": "DFPoolV2.migrateOldPool (DFPoolV2.sol#618-676) uses a dangerous strict equality:\n\t- require(bool,string)(add(_balance,_amount) == IERC20(_srcToken).balanceOf(address(this)),migrateOldPool: Transfer src token to new pool verification failed)\n\t- require(bool,string)(IDSWrappedToken(_tokens[i]).reverseByMultiple(IERC20(_tokens[i]).balanceOf(address(this))) == IERC20(_srcToken).balanceOf(address(this)),migrateOldPool: Pending src token in new pool verification failed)\n"
        },
        {
          "name": "incorrect-equality",
          "vulnerability_from_line": 618,
          "vulnerability_to_line": 676,
          "vulnerability_code": "    function migrateOldPool(address[] calldata _tokens, address _usdx)\n\n        external\n\n        auth\n\n    {\n\n        address _dFPoolOld = dFPoolOld;\n\n        address _dfcol = dfcol;\n\n        address _dTokenController = dTokenController;\n\n        address _srcToken;\n\n        uint256 _amount;\n\n        uint256 _balance;\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n\n            // transfer pending wrapped token to new pool\n\n            _amount = IERC20(_tokens[i]).balanceOf(_dFPoolOld);\n\n            if (_amount > 0)\n\n                DFPoolV1(_dFPoolOld).transferOut(\n\n                    _tokens[i],\n\n                    address(this),\n\n                    _amount\n\n                );\n\n\n\n            // transfer all src token to new pool\n\n            _srcToken = IDSWrappedToken(_tokens[i]).getSrcERC20();\n\n            _amount = IERC20(_srcToken).balanceOf(_dFPoolOld);\n\n            _balance = IERC20(_srcToken).balanceOf(address(this));\n\n            if (_amount > 0)\n\n                DFPoolV1(_dFPoolOld).transferOut(\n\n                    _srcToken,\n\n                    address(this),\n\n                    _amount\n\n                );\n\n            require(\n\n                add(_balance, _amount) ==\n\n                    IERC20(_srcToken).balanceOf(address(this)),\n\n                \"migrateOldPool: Transfer src token to new pool verification failed\"\n\n            );\n\n\n\n            // mint collateral token into dToken\n\n            _amount = IERC20(_tokens[i]).balanceOf(_dfcol);\n\n            if (_amount > 0)\n\n                IDToken(\n\n                    IDTokenController(_dTokenController).getDToken(_srcToken)\n\n                )\n\n                    .mint(\n\n                    address(this),\n\n                    IDSWrappedToken(_tokens[i]).reverseByMultiple(_amount)\n\n                );\n\n            require(\n\n                IDSWrappedToken(_tokens[i]).reverseByMultiple(\n\n                    IERC20(_tokens[i]).balanceOf(address(this))\n\n                ) == IERC20(_srcToken).balanceOf(address(this)),\n\n                \"migrateOldPool: Pending src token in new pool verification failed\"\n\n            );\n\n        }\n\n\n\n        // transfer claimable USDx to new pool\n\n        _amount = IERC20(_usdx).balanceOf(_dFPoolOld);\n\n        if (_amount > 0)\n\n            DFPoolV1(_dFPoolOld).transferOut(_usdx, address(this), _amount);\n",
          "message": "DFPoolV2.migrateOldPool (DFPoolV2.sol#618-676) uses a dangerous strict equality:\n\t- require(bool,string)(add(_balance,_amount) == IERC20(_srcToken).balanceOf(address(this)),migrateOldPool: Transfer src token to new pool verification failed)\n\t- require(bool,string)(IDSWrappedToken(_tokens[i]).reverseByMultiple(IERC20(_tokens[i]).balanceOf(address(this))) == IERC20(_srcToken).balanceOf(address(this)),migrateOldPool: Pending src token in new pool verification failed)\nDFPoolV1.transferFromSender (DFPoolV2.sol#480-494) uses a dangerous strict equality:\n\t- assert(bool)(sub(IERC20(_tokenID).balanceOf(address(this)),_balance) == _amount)\n"
        },
        {
          "name": "incorrect-equality",
          "vulnerability_from_line": 618,
          "vulnerability_to_line": 676,
          "vulnerability_code": "    function migrateOldPool(address[] calldata _tokens, address _usdx)\n\n        external\n\n        auth\n\n    {\n\n        address _dFPoolOld = dFPoolOld;\n\n        address _dfcol = dfcol;\n\n        address _dTokenController = dTokenController;\n\n        address _srcToken;\n\n        uint256 _amount;\n\n        uint256 _balance;\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n\n            // transfer pending wrapped token to new pool\n\n            _amount = IERC20(_tokens[i]).balanceOf(_dFPoolOld);\n\n            if (_amount > 0)\n\n                DFPoolV1(_dFPoolOld).transferOut(\n\n                    _tokens[i],\n\n                    address(this),\n\n                    _amount\n\n                );\n\n\n\n            // transfer all src token to new pool\n\n            _srcToken = IDSWrappedToken(_tokens[i]).getSrcERC20();\n\n            _amount = IERC20(_srcToken).balanceOf(_dFPoolOld);\n\n            _balance = IERC20(_srcToken).balanceOf(address(this));\n\n            if (_amount > 0)\n\n                DFPoolV1(_dFPoolOld).transferOut(\n\n                    _srcToken,\n\n                    address(this),\n\n                    _amount\n\n                );\n\n            require(\n\n                add(_balance, _amount) ==\n\n                    IERC20(_srcToken).balanceOf(address(this)),\n\n                \"migrateOldPool: Transfer src token to new pool verification failed\"\n\n            );\n\n\n\n            // mint collateral token into dToken\n\n            _amount = IERC20(_tokens[i]).balanceOf(_dfcol);\n\n            if (_amount > 0)\n\n                IDToken(\n\n                    IDTokenController(_dTokenController).getDToken(_srcToken)\n\n                )\n\n                    .mint(\n\n                    address(this),\n\n                    IDSWrappedToken(_tokens[i]).reverseByMultiple(_amount)\n\n                );\n\n            require(\n\n                IDSWrappedToken(_tokens[i]).reverseByMultiple(\n\n                    IERC20(_tokens[i]).balanceOf(address(this))\n\n                ) == IERC20(_srcToken).balanceOf(address(this)),\n\n                \"migrateOldPool: Pending src token in new pool verification failed\"\n\n            );\n\n        }\n\n\n\n        // transfer claimable USDx to new pool\n\n        _amount = IERC20(_usdx).balanceOf(_dFPoolOld);\n\n        if (_amount > 0)\n\n            DFPoolV1(_dFPoolOld).transferOut(_usdx, address(this), _amount);\n",
          "message": "DFPoolV2.migrateOldPool (DFPoolV2.sol#618-676) uses a dangerous strict equality:\n\t- require(bool,string)(add(_balance,_amount) == IERC20(_srcToken).balanceOf(address(this)),migrateOldPool: Transfer src token to new pool verification failed)\n\t- require(bool,string)(IDSWrappedToken(_tokens[i]).reverseByMultiple(IERC20(_tokens[i]).balanceOf(address(this))) == IERC20(_srcToken).balanceOf(address(this)),migrateOldPool: Pending src token in new pool verification failed)\nDFPoolV1.transferFromSender (DFPoolV2.sol#480-494) uses a dangerous strict equality:\n\t- assert(bool)(sub(IERC20(_tokenID).balanceOf(address(this)),_balance) == _amount)\nDFPoolV1.transferFromSenderToCol (DFPoolV2.sol#525-541) uses a dangerous strict equality:\n\t- assert(bool)(sub(IERC20(_tokenID).balanceOf(dfcol),_balance) == _amount)\n"
        },
        {
          "name": "incorrect-equality",
          "vulnerability_from_line": 618,
          "vulnerability_to_line": 676,
          "vulnerability_code": "    function migrateOldPool(address[] calldata _tokens, address _usdx)\n\n        external\n\n        auth\n\n    {\n\n        address _dFPoolOld = dFPoolOld;\n\n        address _dfcol = dfcol;\n\n        address _dTokenController = dTokenController;\n\n        address _srcToken;\n\n        uint256 _amount;\n\n        uint256 _balance;\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n\n            // transfer pending wrapped token to new pool\n\n            _amount = IERC20(_tokens[i]).balanceOf(_dFPoolOld);\n\n            if (_amount > 0)\n\n                DFPoolV1(_dFPoolOld).transferOut(\n\n                    _tokens[i],\n\n                    address(this),\n\n                    _amount\n\n                );\n\n\n\n            // transfer all src token to new pool\n\n            _srcToken = IDSWrappedToken(_tokens[i]).getSrcERC20();\n\n            _amount = IERC20(_srcToken).balanceOf(_dFPoolOld);\n\n            _balance = IERC20(_srcToken).balanceOf(address(this));\n\n            if (_amount > 0)\n\n                DFPoolV1(_dFPoolOld).transferOut(\n\n                    _srcToken,\n\n                    address(this),\n\n                    _amount\n\n                );\n\n            require(\n\n                add(_balance, _amount) ==\n\n                    IERC20(_srcToken).balanceOf(address(this)),\n\n                \"migrateOldPool: Transfer src token to new pool verification failed\"\n\n            );\n\n\n\n            // mint collateral token into dToken\n\n            _amount = IERC20(_tokens[i]).balanceOf(_dfcol);\n\n            if (_amount > 0)\n\n                IDToken(\n\n                    IDTokenController(_dTokenController).getDToken(_srcToken)\n\n                )\n\n                    .mint(\n\n                    address(this),\n\n                    IDSWrappedToken(_tokens[i]).reverseByMultiple(_amount)\n\n                );\n\n            require(\n\n                IDSWrappedToken(_tokens[i]).reverseByMultiple(\n\n                    IERC20(_tokens[i]).balanceOf(address(this))\n\n                ) == IERC20(_srcToken).balanceOf(address(this)),\n\n                \"migrateOldPool: Pending src token in new pool verification failed\"\n\n            );\n\n        }\n\n\n\n        // transfer claimable USDx to new pool\n\n        _amount = IERC20(_usdx).balanceOf(_dFPoolOld);\n\n        if (_amount > 0)\n\n            DFPoolV1(_dFPoolOld).transferOut(_usdx, address(this), _amount);\n",
          "message": "DFPoolV2.migrateOldPool (DFPoolV2.sol#618-676) uses a dangerous strict equality:\n\t- require(bool,string)(add(_balance,_amount) == IERC20(_srcToken).balanceOf(address(this)),migrateOldPool: Transfer src token to new pool verification failed)\n\t- require(bool,string)(IDSWrappedToken(_tokens[i]).reverseByMultiple(IERC20(_tokens[i]).balanceOf(address(this))) == IERC20(_srcToken).balanceOf(address(this)),migrateOldPool: Pending src token in new pool verification failed)\nDFPoolV1.transferFromSender (DFPoolV2.sol#480-494) uses a dangerous strict equality:\n\t- assert(bool)(sub(IERC20(_tokenID).balanceOf(address(this)),_balance) == _amount)\nDFPoolV1.transferFromSenderToCol (DFPoolV2.sol#525-541) uses a dangerous strict equality:\n\t- assert(bool)(sub(IERC20(_tokenID).balanceOf(dfcol),_balance) == _amount)\nDFPoolV1.transferOut (DFPoolV2.sol#496-505) uses a dangerous strict equality:\n\t- assert(bool)(sub(IERC20(_tokenID).balanceOf(_to),_balance) == _amount)\n"
        },
        {
          "name": "incorrect-equality",
          "vulnerability_from_line": 618,
          "vulnerability_to_line": 676,
          "vulnerability_code": "    function migrateOldPool(address[] calldata _tokens, address _usdx)\n\n        external\n\n        auth\n\n    {\n\n        address _dFPoolOld = dFPoolOld;\n\n        address _dfcol = dfcol;\n\n        address _dTokenController = dTokenController;\n\n        address _srcToken;\n\n        uint256 _amount;\n\n        uint256 _balance;\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n\n            // transfer pending wrapped token to new pool\n\n            _amount = IERC20(_tokens[i]).balanceOf(_dFPoolOld);\n\n            if (_amount > 0)\n\n                DFPoolV1(_dFPoolOld).transferOut(\n\n                    _tokens[i],\n\n                    address(this),\n\n                    _amount\n\n                );\n\n\n\n            // transfer all src token to new pool\n\n            _srcToken = IDSWrappedToken(_tokens[i]).getSrcERC20();\n\n            _amount = IERC20(_srcToken).balanceOf(_dFPoolOld);\n\n            _balance = IERC20(_srcToken).balanceOf(address(this));\n\n            if (_amount > 0)\n\n                DFPoolV1(_dFPoolOld).transferOut(\n\n                    _srcToken,\n\n                    address(this),\n\n                    _amount\n\n                );\n\n            require(\n\n                add(_balance, _amount) ==\n\n                    IERC20(_srcToken).balanceOf(address(this)),\n\n                \"migrateOldPool: Transfer src token to new pool verification failed\"\n\n            );\n\n\n\n            // mint collateral token into dToken\n\n            _amount = IERC20(_tokens[i]).balanceOf(_dfcol);\n\n            if (_amount > 0)\n\n                IDToken(\n\n                    IDTokenController(_dTokenController).getDToken(_srcToken)\n\n                )\n\n                    .mint(\n\n                    address(this),\n\n                    IDSWrappedToken(_tokens[i]).reverseByMultiple(_amount)\n\n                );\n\n            require(\n\n                IDSWrappedToken(_tokens[i]).reverseByMultiple(\n\n                    IERC20(_tokens[i]).balanceOf(address(this))\n\n                ) == IERC20(_srcToken).balanceOf(address(this)),\n\n                \"migrateOldPool: Pending src token in new pool verification failed\"\n\n            );\n\n        }\n\n\n\n        // transfer claimable USDx to new pool\n\n        _amount = IERC20(_usdx).balanceOf(_dFPoolOld);\n\n        if (_amount > 0)\n\n            DFPoolV1(_dFPoolOld).transferOut(_usdx, address(this), _amount);\n",
          "message": "DFPoolV2.migrateOldPool (DFPoolV2.sol#618-676) uses a dangerous strict equality:\n\t- require(bool,string)(add(_balance,_amount) == IERC20(_srcToken).balanceOf(address(this)),migrateOldPool: Transfer src token to new pool verification failed)\n\t- require(bool,string)(IDSWrappedToken(_tokens[i]).reverseByMultiple(IERC20(_tokens[i]).balanceOf(address(this))) == IERC20(_srcToken).balanceOf(address(this)),migrateOldPool: Pending src token in new pool verification failed)\nDFPoolV1.transferFromSender (DFPoolV2.sol#480-494) uses a dangerous strict equality:\n\t- assert(bool)(sub(IERC20(_tokenID).balanceOf(address(this)),_balance) == _amount)\nDFPoolV1.transferFromSenderToCol (DFPoolV2.sol#525-541) uses a dangerous strict equality:\n\t- assert(bool)(sub(IERC20(_tokenID).balanceOf(dfcol),_balance) == _amount)\nDFPoolV1.transferOut (DFPoolV2.sol#496-505) uses a dangerous strict equality:\n\t- assert(bool)(sub(IERC20(_tokenID).balanceOf(_to),_balance) == _amount)\nDFPoolV1.transferToCol (DFPoolV2.sol#507-523) uses a dangerous strict equality:\n\t- assert(bool)(sub(IERC20(_tokenID).balanceOf(dfcol),_balance) == _amount)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 618,
          "vulnerability_to_line": 676,
          "vulnerability_code": "    function migrateOldPool(address[] calldata _tokens, address _usdx)\n\n        external\n\n        auth\n\n    {\n\n        address _dFPoolOld = dFPoolOld;\n\n        address _dfcol = dfcol;\n\n        address _dTokenController = dTokenController;\n\n        address _srcToken;\n\n        uint256 _amount;\n\n        uint256 _balance;\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n\n            // transfer pending wrapped token to new pool\n\n            _amount = IERC20(_tokens[i]).balanceOf(_dFPoolOld);\n\n            if (_amount > 0)\n\n                DFPoolV1(_dFPoolOld).transferOut(\n\n                    _tokens[i],\n\n                    address(this),\n\n                    _amount\n\n                );\n\n\n\n            // transfer all src token to new pool\n\n            _srcToken = IDSWrappedToken(_tokens[i]).getSrcERC20();\n\n            _amount = IERC20(_srcToken).balanceOf(_dFPoolOld);\n\n            _balance = IERC20(_srcToken).balanceOf(address(this));\n\n            if (_amount > 0)\n\n                DFPoolV1(_dFPoolOld).transferOut(\n\n                    _srcToken,\n\n                    address(this),\n\n                    _amount\n\n                );\n\n            require(\n\n                add(_balance, _amount) ==\n\n                    IERC20(_srcToken).balanceOf(address(this)),\n\n                \"migrateOldPool: Transfer src token to new pool verification failed\"\n\n            );\n\n\n\n            // mint collateral token into dToken\n\n            _amount = IERC20(_tokens[i]).balanceOf(_dfcol);\n\n            if (_amount > 0)\n\n                IDToken(\n\n                    IDTokenController(_dTokenController).getDToken(_srcToken)\n\n                )\n\n                    .mint(\n\n                    address(this),\n\n                    IDSWrappedToken(_tokens[i]).reverseByMultiple(_amount)\n\n                );\n\n            require(\n\n                IDSWrappedToken(_tokens[i]).reverseByMultiple(\n\n                    IERC20(_tokens[i]).balanceOf(address(this))\n\n                ) == IERC20(_srcToken).balanceOf(address(this)),\n\n                \"migrateOldPool: Pending src token in new pool verification failed\"\n\n            );\n\n        }\n\n\n\n        // transfer claimable USDx to new pool\n\n        _amount = IERC20(_usdx).balanceOf(_dFPoolOld);\n\n        if (_amount > 0)\n\n            DFPoolV1(_dFPoolOld).transferOut(_usdx, address(this), _amount);\n",
          "message": "DFPoolV2.migrateOldPool (DFPoolV2.sol#618-676) does not use the value returned by external calls:\n\t-DFPoolV1(_dFPoolOld).transferOut(_tokens[i],address(this),_amount) (DFPoolV2.sol#632-636)\n\t-DFPoolV1(_dFPoolOld).transferOut(_srcToken,address(this),_amount) (DFPoolV2.sol#643-647)\n\t-DFPoolV1(_dFPoolOld).transferOut(_usdx,address(this),_amount) (DFPoolV2.sol#675)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 630,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _amount = IERC20(_tokens[i]).balanceOf(_dFPoolOld);\n",
          "message": "DFPoolV2.migrateOldPool has external calls inside a loop:\n\t- _amount = IERC20(_tokens[i]).balanceOf(_dFPoolOld) (DFPoolV2.sol#630)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 632,
          "vulnerability_to_line": 636,
          "vulnerability_code": "                DFPoolV1(_dFPoolOld).transferOut(\n\n                    _tokens[i],\n\n                    address(this),\n\n                    _amount\n",
          "message": "DFPoolV2.migrateOldPool has external calls inside a loop:\n\t- DFPoolV1(_dFPoolOld).transferOut(_tokens[i],address(this),_amount) (DFPoolV2.sol#632-636)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 639,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _srcToken = IDSWrappedToken(_tokens[i]).getSrcERC20();\n",
          "message": "DFPoolV2.migrateOldPool has external calls inside a loop:\n\t- _srcToken = IDSWrappedToken(_tokens[i]).getSrcERC20() (DFPoolV2.sol#639)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 640,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _amount = IERC20(_srcToken).balanceOf(_dFPoolOld);\n",
          "message": "DFPoolV2.migrateOldPool has external calls inside a loop:\n\t- _amount = IERC20(_srcToken).balanceOf(_dFPoolOld) (DFPoolV2.sol#640)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 641,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _balance = IERC20(_srcToken).balanceOf(address(this));\n",
          "message": "DFPoolV2.migrateOldPool has external calls inside a loop:\n\t- _balance = IERC20(_srcToken).balanceOf(address(this)) (DFPoolV2.sol#641)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 643,
          "vulnerability_to_line": 647,
          "vulnerability_code": "                DFPoolV1(_dFPoolOld).transferOut(\n\n                    _srcToken,\n\n                    address(this),\n\n                    _amount\n",
          "message": "DFPoolV2.migrateOldPool has external calls inside a loop:\n\t- DFPoolV1(_dFPoolOld).transferOut(_srcToken,address(this),_amount) (DFPoolV2.sol#643-647)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 648,
          "vulnerability_to_line": 652,
          "vulnerability_code": "            require(\n\n                add(_balance, _amount) ==\n\n                    IERC20(_srcToken).balanceOf(address(this)),\n\n                \"migrateOldPool: Transfer src token to new pool verification failed\"\n",
          "message": "DFPoolV2.migrateOldPool has external calls inside a loop:\n\t- require(bool,string)(add(_balance,_amount) == IERC20(_srcToken).balanceOf(address(this)),migrateOldPool: Transfer src token to new pool verification failed) (DFPoolV2.sol#648-652)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 655,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _amount = IERC20(_tokens[i]).balanceOf(_dfcol);\n",
          "message": "DFPoolV2.migrateOldPool has external calls inside a loop:\n\t- _amount = IERC20(_tokens[i]).balanceOf(_dfcol) (DFPoolV2.sol#655)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 657,
          "vulnerability_to_line": 663,
          "vulnerability_code": "                IDToken(\n\n                    IDTokenController(_dTokenController).getDToken(_srcToken)\n\n                )\n\n                    .mint(\n\n                    address(this),\n\n                    IDSWrappedToken(_tokens[i]).reverseByMultiple(_amount)\n",
          "message": "DFPoolV2.migrateOldPool has external calls inside a loop:\n\t- IDToken(IDTokenController(_dTokenController).getDToken(_srcToken)).mint(address(this),IDSWrappedToken(_tokens[i]).reverseByMultiple(_amount)) (DFPoolV2.sol#657-663)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 664,
          "vulnerability_to_line": 669,
          "vulnerability_code": "            require(\n\n                IDSWrappedToken(_tokens[i]).reverseByMultiple(\n\n                    IERC20(_tokens[i]).balanceOf(address(this))\n\n                ) == IERC20(_srcToken).balanceOf(address(this)),\n\n                \"migrateOldPool: Pending src token in new pool verification failed\"\n",
          "message": "DFPoolV2.migrateOldPool has external calls inside a loop:\n\t- require(bool,string)(IDSWrappedToken(_tokens[i]).reverseByMultiple(IERC20(_tokens[i]).balanceOf(address(this))) == IERC20(_srcToken).balanceOf(address(this)),migrateOldPool: Pending src token in new pool verification failed) (DFPoolV2.sol#664-669)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 93,
          "vulnerability_to_line": 117,
          "vulnerability_code": "    function doTransferOut(\n\n        address _token,\n\n        address _to,\n\n        uint256 _amount\n\n    ) internal returns (bool) {\n\n        IERC20 token = IERC20(_token);\n\n        bool result;\n\n\n\n        token.transfer(_to, _amount);\n\n\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {\n\n                    result := not(0)\n\n                }\n\n                case 32 {\n\n                    returndatacopy(0, 0, 32)\n\n                    result := mload(0)\n\n                }\n\n                default {\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n        return result;\n",
          "message": "ERC20SafeTransfer.doTransferOut uses assembly (DFPoolV2.sol#93-117)\n\t- DFPoolV2.sol#103-115\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": 144,
          "vulnerability_code": "    function doTransferFrom(\n\n        address _token,\n\n        address _from,\n\n        address _to,\n\n        uint256 _amount\n\n    ) internal returns (bool) {\n\n        IERC20 token = IERC20(_token);\n\n        bool result;\n\n\n\n        token.transferFrom(_from, _to, _amount);\n\n\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {\n\n                    result := not(0)\n\n                }\n\n                case 32 {\n\n                    returndatacopy(0, 0, 32)\n\n                    result := mload(0)\n\n                }\n\n                default {\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n        return result;\n",
          "message": "ERC20SafeTransfer.doTransferFrom uses assembly (DFPoolV2.sol#119-144)\n\t- DFPoolV2.sol#130-142\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 146,
          "vulnerability_to_line": 170,
          "vulnerability_code": "    function doApprove(\n\n        address _token,\n\n        address _to,\n\n        uint256 _amount\n\n    ) internal returns (bool) {\n\n        IERC20 token = IERC20(_token);\n\n        bool result;\n\n\n\n        token.approve(_to, _amount);\n\n\n\n        assembly {\n\n            switch returndatasize()\n\n                case 0 {\n\n                    result := not(0)\n\n                }\n\n                case 32 {\n\n                    returndatacopy(0, 0, 32)\n\n                    result := mload(0)\n\n                }\n\n                default {\n\n                    revert(0, 0)\n\n                }\n\n        }\n\n        return result;\n",
          "message": "ERC20SafeTransfer.doApprove uses assembly (DFPoolV2.sol#146-170)\n\t- DFPoolV2.sol#156-168\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 268,
          "vulnerability_to_line": 284,
          "vulnerability_code": "    function pow(uint256 base, uint256 exponent) public pure returns (uint256) {\n\n        if (exponent == 0) {\n\n            return 1;\n\n        }\n\n        else if (exponent == 1) {\n\n            return base;\n\n        }\n\n        else if (base == 0 && exponent != 0) {\n\n            return 0;\n\n        }\n\n        else {\n\n            uint256 z = base;\n\n            for (uint256 i = 1; i < exponent; i++)\n\n                z = mul(z, base);\n\n            return z;\n\n        }\n",
          "message": "DSMath.pow (DFPoolV2.sol#268-284) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 305,
          "vulnerability_to_line": 307,
          "vulnerability_code": "    function canCall(\n\n        address src, address dst, bytes4 sig\n",
          "message": "DSAuthority.canCall (DFPoolV2.sol#305-307) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 327,
          "vulnerability_to_line": 330,
          "vulnerability_code": "    function disableOwnership() public onlyOwner {\n\n        owner = address(0);\n\n        emit OwnerUpdate(msg.sender, owner);\n",
          "message": "DSAuth.disableOwnership (DFPoolV2.sol#327-330) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 332,
          "vulnerability_to_line": 335,
          "vulnerability_code": "    function transferOwnership(address newOwner_) public onlyOwner {\n\n        require(newOwner_ != owner, \"TransferOwnership: the same owner.\");\n\n        newOwner = newOwner_;\n",
          "message": "DSAuth.transferOwnership (DFPoolV2.sol#332-335) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 337,
          "vulnerability_to_line": 342,
          "vulnerability_code": "    function acceptOwnership() public {\n\n        require(msg.sender == newOwner, \"AcceptOwnership: only new owner do this.\");\n\n        emit OwnerUpdate(owner, newOwner);\n\n        owner = newOwner;\n\n        newOwner = address(0x0);\n",
          "message": "DSAuth.acceptOwnership (DFPoolV2.sol#337-342) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 345,
          "vulnerability_to_line": 351,
          "vulnerability_code": "    function setAuthority(DSAuthority authority_)\n\n        public\n\n        onlyOwner\n\n    {\n\n        authority = authority_;\n\n        emit LogSetAuthority(address(authority));\n",
          "message": "DSAuth.setAuthority (DFPoolV2.sol#345-351) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 441,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address _owner) public view returns (uint);\n",
          "message": "IERC20Token.balanceOf (DFPoolV2.sol#441) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 442,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function allowance(address _owner, address _spender) public view returns (uint);\n",
          "message": "IERC20Token.allowance (DFPoolV2.sol#442) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 443,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transfer(address _to, uint _value) public returns (bool success);\n",
          "message": "IERC20Token.transfer (DFPoolV2.sol#443) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 444,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n",
          "message": "IERC20Token.transferFrom (DFPoolV2.sol#444) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 445,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _spender, uint _value) public returns (bool success);\n",
          "message": "IERC20Token.approve (DFPoolV2.sol#445) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 446,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function totalSupply() public view returns (uint);\n",
          "message": "IERC20Token.totalSupply (DFPoolV2.sol#446) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 454,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function mint(address _account, uint _value) public;\n",
          "message": "IDSWrappedToken.mint (DFPoolV2.sol#454) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 455,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function burn(address _account, uint _value) public;\n",
          "message": "IDSWrappedToken.burn (DFPoolV2.sol#455) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 456,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function wrap(address _dst, uint _amount) public returns (uint);\n",
          "message": "IDSWrappedToken.wrap (DFPoolV2.sol#456) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 457,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function unwrap(address _dst, uint _amount) public returns (uint);\n",
          "message": "IDSWrappedToken.unwrap (DFPoolV2.sol#457) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 458,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function changeByMultiple(uint _amount) public view returns (uint);\n",
          "message": "IDSWrappedToken.changeByMultiple (DFPoolV2.sol#458) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 459,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function reverseByMultiple(uint _xAmount) public view returns (uint);\n",
          "message": "IDSWrappedToken.reverseByMultiple (DFPoolV2.sol#459) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 460,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getSrcERC20() public view returns (address);\n",
          "message": "IDSWrappedToken.getSrcERC20 (DFPoolV2.sol#460) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 525,
          "vulnerability_to_line": 541,
          "vulnerability_code": "    function transferFromSenderToCol(\n\n        address _tokenID,\n\n        address _from,\n\n        uint256 _amount\n\n    ) public auth returns (bool) {\n\n        require(\n\n            dfcol != address(0),\n\n            \"TransferFromSenderToCol: collateral address empty.\"\n\n        );\n\n        uint256 _balance = IERC20(_tokenID).balanceOf(dfcol);\n\n        require(\n\n            doTransferFrom(_tokenID, _from, dfcol, _amount),\n\n            \"transferFromSenderToCol: failed\"\n\n        );\n\n        assert(sub(IERC20(_tokenID).balanceOf(dfcol), _balance) == _amount);\n\n        return true;\n",
          "message": "DFPoolV1.transferFromSenderToCol (DFPoolV2.sol#525-541) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 543,
          "vulnerability_to_line": 551,
          "vulnerability_code": "    function approveToEngine(address _tokenIdx, address _engineAddress)\n\n        public\n\n        auth\n\n    {\n\n        require(\n\n            doApprove(_tokenIdx, _engineAddress, uint256(-1)),\n\n            \"approveToEngine: Approve failed!\"\n\n        );\n",
          "message": "DFPoolV1.approveToEngine (DFPoolV2.sol#543-551) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 581,
          "vulnerability_to_line": 592,
          "vulnerability_code": "    function transferFromSenderOneClick(\n\n        address _tokenID,\n\n        address _from,\n\n        uint256 _amount\n\n    ) public returns (bool) {\n\n        super.transferFromSender(_tokenID, _from, _amount);\n\n        IDToken(IDTokenController(dTokenController).getDToken(_tokenID)).mint(\n\n            address(this),\n\n            _amount\n\n        );\n\n        return true;\n",
          "message": "DFPoolV2.transferFromSenderOneClick (DFPoolV2.sol#581-592) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 594,
          "vulnerability_to_line": 603,
          "vulnerability_code": "    function transferOutSrc(\n\n        address _tokenID,\n\n        address _to,\n\n        uint256 _amount\n\n    ) public returns (bool) {\n\n        IDToken(IDTokenController(dTokenController).getDToken(_tokenID))\n\n            .redeemUnderlying(address(this), _amount);\n\n        transferOut(_tokenID, _to, _amount);\n\n        return true;\n",
          "message": "DFPoolV2.transferOutSrc (DFPoolV2.sol#594-603) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 693,
          "vulnerability_to_line": 699,
          "vulnerability_code": "    function getInterestByXToken(address _xToken) public returns (address, uint256) {\n\n\n\n        address _token = IDSWrappedToken(_xToken).getSrcERC20();\n\n        uint256 _xBalance = IDSWrappedToken(_xToken).changeByMultiple(getUnderlying(_token)); \n\n        uint256 _xPrincipal = IERC20(_xToken).balanceOf(dfcol);\n\n        return (_token, _xBalance > _xPrincipal ? sub(_xBalance, _xPrincipal) : 0);\n",
          "message": "DFPoolV2.getInterestByXToken (DFPoolV2.sol#693-699) should be declared external\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 94,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _token,\n",
          "message": "Parameter '_token' of ERC20SafeTransfer.doTransferOut (DFPoolV2.sol#94) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 95,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _to,\n",
          "message": "Parameter '_to' of ERC20SafeTransfer.doTransferOut (DFPoolV2.sol#95) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 96,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _amount\n",
          "message": "Parameter '_amount' of ERC20SafeTransfer.doTransferOut (DFPoolV2.sol#96) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 120,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _token,\n",
          "message": "Parameter '_token' of ERC20SafeTransfer.doTransferFrom (DFPoolV2.sol#120) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 121,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _from,\n",
          "message": "Parameter '_from' of ERC20SafeTransfer.doTransferFrom (DFPoolV2.sol#121) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 122,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _to,\n",
          "message": "Parameter '_to' of ERC20SafeTransfer.doTransferFrom (DFPoolV2.sol#122) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 123,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _amount\n",
          "message": "Parameter '_amount' of ERC20SafeTransfer.doTransferFrom (DFPoolV2.sol#123) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 147,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _token,\n",
          "message": "Parameter '_token' of ERC20SafeTransfer.doApprove (DFPoolV2.sol#147) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 148,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _to,\n",
          "message": "Parameter '_to' of ERC20SafeTransfer.doApprove (DFPoolV2.sol#148) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 149,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _amount\n",
          "message": "Parameter '_amount' of ERC20SafeTransfer.doApprove (DFPoolV2.sol#149) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _dfcol) public {\n",
          "message": "Parameter '_dfcol' of DFPoolV1. (DFPoolV2.sol#476) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 481,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _tokenID,\n",
          "message": "Parameter '_tokenID' of DFPoolV1.transferFromSender (DFPoolV2.sol#481) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 482,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _from,\n",
          "message": "Parameter '_from' of DFPoolV1.transferFromSender (DFPoolV2.sol#482) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 483,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _amount\n",
          "message": "Parameter '_amount' of DFPoolV1.transferFromSender (DFPoolV2.sol#483) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 497,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _tokenID,\n",
          "message": "Parameter '_tokenID' of DFPoolV1.transferOut (DFPoolV2.sol#497) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 498,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _to,\n",
          "message": "Parameter '_to' of DFPoolV1.transferOut (DFPoolV2.sol#498) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 499,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _amount\n",
          "message": "Parameter '_amount' of DFPoolV1.transferOut (DFPoolV2.sol#499) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 507,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferToCol(address _tokenID, uint256 _amount)\n",
          "message": "Parameter '_tokenID' of DFPoolV1.transferToCol (DFPoolV2.sol#507) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 507,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferToCol(address _tokenID, uint256 _amount)\n",
          "message": "Parameter '_amount' of DFPoolV1.transferToCol (DFPoolV2.sol#507) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 526,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _tokenID,\n",
          "message": "Parameter '_tokenID' of DFPoolV1.transferFromSenderToCol (DFPoolV2.sol#526) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 527,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _from,\n",
          "message": "Parameter '_from' of DFPoolV1.transferFromSenderToCol (DFPoolV2.sol#527) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 528,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _amount\n",
          "message": "Parameter '_amount' of DFPoolV1.transferFromSenderToCol (DFPoolV2.sol#528) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 543,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approveToEngine(address _tokenIdx, address _engineAddress)\n",
          "message": "Parameter '_tokenIdx' of DFPoolV1.approveToEngine (DFPoolV2.sol#543) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 543,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approveToEngine(address _tokenIdx, address _engineAddress)\n",
          "message": "Parameter '_engineAddress' of DFPoolV1.approveToEngine (DFPoolV2.sol#543) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 605,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferToCol(address _tokenID, uint256 _amount)\n",
          "message": "Parameter '_tokenID' of DFPoolV2.transferToCol (DFPoolV2.sol#605) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 605,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferToCol(address _tokenID, uint256 _amount)\n",
          "message": "Parameter '_amount' of DFPoolV2.transferToCol (DFPoolV2.sol#605) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 560,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _dfcol,\n",
          "message": "Parameter '_dfcol' of DFPoolV2. (DFPoolV2.sol#560) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 561,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _dFPoolOld,\n",
          "message": "Parameter '_dFPoolOld' of DFPoolV2. (DFPoolV2.sol#561) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 562,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _dTokenController\n",
          "message": "Parameter '_dTokenController' of DFPoolV2. (DFPoolV2.sol#562) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 569,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _dfcol,\n",
          "message": "Parameter '_dfcol' of DFPoolV2.initialize (DFPoolV2.sol#569) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 570,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _dFPoolOld,\n",
          "message": "Parameter '_dFPoolOld' of DFPoolV2.initialize (DFPoolV2.sol#570) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 571,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _dTokenController\n",
          "message": "Parameter '_dTokenController' of DFPoolV2.initialize (DFPoolV2.sol#571) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 582,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _tokenID,\n",
          "message": "Parameter '_tokenID' of DFPoolV2.transferFromSenderOneClick (DFPoolV2.sol#582) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 583,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _from,\n",
          "message": "Parameter '_from' of DFPoolV2.transferFromSenderOneClick (DFPoolV2.sol#583) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 584,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _amount\n",
          "message": "Parameter '_amount' of DFPoolV2.transferFromSenderOneClick (DFPoolV2.sol#584) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 595,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _tokenID,\n",
          "message": "Parameter '_tokenID' of DFPoolV2.transferOutSrc (DFPoolV2.sol#595) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 596,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _to,\n",
          "message": "Parameter '_to' of DFPoolV2.transferOutSrc (DFPoolV2.sol#596) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 597,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _amount\n",
          "message": "Parameter '_amount' of DFPoolV2.transferOutSrc (DFPoolV2.sol#597) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 618,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function migrateOldPool(address[] calldata _tokens, address _usdx)\n",
          "message": "Parameter '_tokens' of DFPoolV2.migrateOldPool (DFPoolV2.sol#618) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 618,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function migrateOldPool(address[] calldata _tokens, address _usdx)\n",
          "message": "Parameter '_usdx' of DFPoolV2.migrateOldPool (DFPoolV2.sol#618) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 678,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _tokenID) external auth {\n",
          "message": "Parameter '_tokenID' of DFPoolV2.approve (DFPoolV2.sol#678) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 693,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getInterestByXToken(address _xToken) public returns (address, uint256) {\n",
          "message": "Parameter '_xToken' of DFPoolV2.getInterestByXToken (DFPoolV2.sol#693) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 701,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getUnderlying(address _underlying) public returns (uint256) {\n",
          "message": "Parameter '_underlying' of DFPoolV2.getUnderlying (DFPoolV2.sol#701) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 328,
          "vulnerability_to_line": null,
          "vulnerability_code": "        owner = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 554,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract DFPoolV2 is ERC20SafeTransfer, DFPoolV1(address(0)) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 341,
          "vulnerability_to_line": null,
          "vulnerability_code": "        newOwner = address(0x0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ERC20_APPROVE",
          "vulnerability_from_line": 678,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _tokenID) external auth {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 628,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _tokens.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 628,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _tokens.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 345,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setAuthority(DSAuthority authority_)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.2;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 90,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.2;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 190,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.2;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 302,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.2;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 382,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.2;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 396,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.2;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 427,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.2;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 435,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.2;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 451,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.2;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 465,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.2;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 555,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool private initialized;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 407,
          "vulnerability_to_line": null,
          "vulnerability_code": "    returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 418,
          "vulnerability_to_line": null,
          "vulnerability_code": "    returns (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 693,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getInterestByXToken(address _xToken) public returns (address, uint256) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 103,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 130,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 156,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 221,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant WAD = 10 ** 18;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 474,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address dfcol;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 556,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address dFPoolOld;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 557,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address dTokenController;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "DOCKER_TIMEOUT"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}