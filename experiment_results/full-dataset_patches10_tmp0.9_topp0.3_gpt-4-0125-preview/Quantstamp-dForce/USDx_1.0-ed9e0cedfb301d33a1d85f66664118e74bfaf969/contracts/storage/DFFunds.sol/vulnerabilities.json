{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 165,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 166,
          "vulnerability_to_line": null,
          "vulnerability_code": "        owner = msg.sender;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 167,
          "vulnerability_to_line": null,
          "vulnerability_code": "        emit LogSetOwner(msg.sender);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 168,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 38,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require((z = x + y) >= x, \"ds-math-add-overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 41,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 44,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 48,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(y > 0, \"ds-math-div-overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 177,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newOwner_ != owner, \"TransferOwnership: the same owner.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 182,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == newOwner, \"AcceptOwnership: only new owner do this.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 198,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(isOwner(msg.sender), \"ds-auth-non-owner\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 207,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 233,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_address != address(0), \"ValidAddress: address invalid.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": null,
          "vulnerability_code": "        else if (base == 0 && exponent != 0) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 120,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return 0;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 121,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 122,
          "vulnerability_to_line": null,
          "vulnerability_code": "        else {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 123,
          "vulnerability_to_line": null,
          "vulnerability_code": "            uint256 z = base;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 124,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint256 i = 1; i < exponent; i++)\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 125,
          "vulnerability_to_line": null,
          "vulnerability_code": "                z = mul(z, base);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 126,
          "vulnerability_to_line": null,
          "vulnerability_code": "            return z;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 127,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 124,
          "vulnerability_to_line": null,
          "vulnerability_code": "            for (uint256 i = 1; i < exponent; i++)\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 177,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newOwner_ != owner, \"TransferOwnership: the same owner.\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 182,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == newOwner, \"AcceptOwnership: only new owner do this.\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_18"
      ],
      "vulnerability_findings": [
        {
          "name": "incorrect-equality",
          "vulnerability_from_line": 247,
          "vulnerability_to_line": 257,
          "vulnerability_code": "    function transferOut(address _tokenID, address _to, uint _amount)\n\n        public\n\n        validAddress(_to)\n\n        auth\n\n        returns (bool)\n\n    {\n\n        uint _balance = IERC20Token(_tokenID).balanceOf(_to);\n\n        IERC20Token(_tokenID).transfer(_to, _amount);\n\n        assert(sub(IERC20Token(_tokenID).balanceOf(_to), _balance) == _amount);\n\n        return true;\n",
          "message": "DFFunds.transferOut (DFFunds.sol#247-257) uses a dangerous strict equality:\n\t- assert(bool)(sub(IERC20Token(_tokenID).balanceOf(_to),_balance) == _amount)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 247,
          "vulnerability_to_line": 257,
          "vulnerability_code": "    function transferOut(address _tokenID, address _to, uint _amount)\n\n        public\n\n        validAddress(_to)\n\n        auth\n\n        returns (bool)\n\n    {\n\n        uint _balance = IERC20Token(_tokenID).balanceOf(_to);\n\n        IERC20Token(_tokenID).transfer(_to, _amount);\n\n        assert(sub(IERC20Token(_tokenID).balanceOf(_to), _balance) == _amount);\n\n        return true;\n",
          "message": "DFFunds.transferOut (DFFunds.sol#247-257) does not use the value returned by external calls:\n\t-IERC20Token(_tokenID).transfer(_to,_amount) (DFFunds.sol#254)\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 9,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address _owner) public view returns (uint);\n",
          "message": "IERC20Token.balanceOf (DFFunds.sol#9) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 10,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function allowance(address _owner, address _spender) public view returns (uint);\n",
          "message": "IERC20Token.allowance (DFFunds.sol#10) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 11,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transfer(address _to, uint _value) public returns (bool success);\n",
          "message": "IERC20Token.transfer (DFFunds.sol#11) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 12,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n",
          "message": "IERC20Token.transferFrom (DFFunds.sol#12) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 13,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function approve(address _spender, uint _value) public returns (bool success);\n",
          "message": "IERC20Token.approve (DFFunds.sol#13) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 14,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function totalSupply() public view returns (uint);\n",
          "message": "IERC20Token.totalSupply (DFFunds.sol#14) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 112,
          "vulnerability_to_line": 128,
          "vulnerability_code": "    function pow(uint256 base, uint256 exponent) public pure returns (uint256) {\n\n        if (exponent == 0) {\n\n            return 1;\n\n        }\n\n        else if (exponent == 1) {\n\n            return base;\n\n        }\n\n        else if (base == 0 && exponent != 0) {\n\n            return 0;\n\n        }\n\n        else {\n\n            uint256 z = base;\n\n            for (uint256 i = 1; i < exponent; i++)\n\n                z = mul(z, base);\n\n            return z;\n\n        }\n",
          "message": "DSMath.pow (DFFunds.sol#112-128) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 149,
          "vulnerability_to_line": 151,
          "vulnerability_code": "    function canCall(\n\n        address src, address dst, bytes4 sig\n",
          "message": "DSAuthority.canCall (DFFunds.sol#149-151) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 171,
          "vulnerability_to_line": 174,
          "vulnerability_code": "    function disableOwnership() public onlyOwner {\n\n        owner = address(0);\n\n        emit OwnerUpdate(msg.sender, owner);\n",
          "message": "DSAuth.disableOwnership (DFFunds.sol#171-174) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 176,
          "vulnerability_to_line": 179,
          "vulnerability_code": "    function transferOwnership(address newOwner_) public onlyOwner {\n\n        require(newOwner_ != owner, \"TransferOwnership: the same owner.\");\n\n        newOwner = newOwner_;\n",
          "message": "DSAuth.transferOwnership (DFFunds.sol#176-179) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 181,
          "vulnerability_to_line": 186,
          "vulnerability_code": "    function acceptOwnership() public {\n\n        require(msg.sender == newOwner, \"AcceptOwnership: only new owner do this.\");\n\n        emit OwnerUpdate(owner, newOwner);\n\n        owner = newOwner;\n\n        newOwner = address(0x0);\n",
          "message": "DSAuth.acceptOwnership (DFFunds.sol#181-186) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 189,
          "vulnerability_to_line": 195,
          "vulnerability_code": "    function setAuthority(DSAuthority authority_)\n\n        public\n\n        onlyOwner\n\n    {\n\n        authority = authority_;\n\n        emit LogSetAuthority(address(authority));\n",
          "message": "DSAuth.setAuthority (DFFunds.sol#189-195) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 247,
          "vulnerability_to_line": 257,
          "vulnerability_code": "    function transferOut(address _tokenID, address _to, uint _amount)\n\n        public\n\n        validAddress(_to)\n\n        auth\n\n        returns (bool)\n\n    {\n\n        uint _balance = IERC20Token(_tokenID).balanceOf(_to);\n\n        IERC20Token(_tokenID).transfer(_to, _amount);\n\n        assert(sub(IERC20Token(_tokenID).balanceOf(_to), _balance) == _amount);\n\n        return true;\n",
          "message": "DFFunds.transferOut (DFFunds.sol#247-257) should be declared external\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 247,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferOut(address _tokenID, address _to, uint _amount)\n",
          "message": "Parameter '_tokenID' of DFFunds.transferOut (DFFunds.sol#247) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 247,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferOut(address _tokenID, address _to, uint _amount)\n",
          "message": "Parameter '_to' of DFFunds.transferOut (DFFunds.sol#247) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 247,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferOut(address _tokenID, address _to, uint _amount)\n",
          "message": "Parameter '_amount' of DFFunds.transferOut (DFFunds.sol#247) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 172,
          "vulnerability_to_line": null,
          "vulnerability_code": "        owner = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 185,
          "vulnerability_to_line": null,
          "vulnerability_code": "        newOwner = address(0x0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 189,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setAuthority(DSAuthority authority_)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.2;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 34,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.2;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 146,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.2;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 226,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.2;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 240,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.2;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 65,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant WAD = 10 ** 18;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 253,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint _balance = IERC20Token(_tokenID).balanceOf(_to);\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 254,
          "vulnerability_to_line": null,
          "vulnerability_code": "        IERC20Token(_tokenID).transfer(_to, _amount);\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 254,
          "vulnerability_to_line": null,
          "vulnerability_code": "        IERC20Token(_tokenID).transfer(_to, _amount);\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        },
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 255,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assert(sub(IERC20Token(_tokenID).balanceOf(_to), _balance) == _amount);\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 40,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function sub(uint x, uint y) internal pure returns (uint z) {\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}