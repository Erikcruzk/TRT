{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": null,
          "vulnerability_code": "            revert(\"ECDSA: invalid signature length\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 58,
          "vulnerability_to_line": null,
          "vulnerability_code": "            revert(\"ECDSA: invalid signature 's' value\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": null,
          "vulnerability_code": "            revert(\"ECDSA: invalid signature 'v' value\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 67,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(signer != address(0), \"ECDSA: invalid signature\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 61,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (v != 27 && v != 28) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": null,
          "vulnerability_code": "            revert(\"ECDSA: invalid signature 'v' value\");\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 58,
          "vulnerability_to_line": null,
          "vulnerability_code": "            revert(\"ECDSA: invalid signature 's' value\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 62,
          "vulnerability_to_line": null,
          "vulnerability_code": "            revert(\"ECDSA: invalid signature 'v' value\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_3"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 28,
          "vulnerability_to_line": 72,
          "vulnerability_code": "    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n\n        // Check the signature length\n\n        if (signature.length != 65) {\n\n            revert(\"ECDSA: invalid signature length\");\n\n        }\n\n\n\n        // Divide the signature in r, s and v variables\n\n        bytes32 r;\n\n        bytes32 s;\n\n        uint8 v;\n\n\n\n        // ecrecover takes the signature parameters, and the only way to get them\n\n        // currently is to use assembly.\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            r := mload(add(signature, 0x20))\n\n            s := mload(add(signature, 0x40))\n\n            v := byte(0, mload(add(signature, 0x60)))\n\n        }\n\n\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\n\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n\n        //\n\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n\n        // these malleable signatures as well.\n\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n\n            revert(\"ECDSA: invalid signature 's' value\");\n\n        }\n\n\n\n        if (v != 27 && v != 28) {\n\n            revert(\"ECDSA: invalid signature 'v' value\");\n\n        }\n\n\n\n        // If the signature is valid (and not malleable), return the signer address\n\n        address signer = ecrecover(hash, v, r, s);\n\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n\n\n        return signer;\n\n    }\n\n\n",
          "message": "ECDSA.recover (ECDSA.sol#28-72) is declared view but contains assembly code\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 28,
          "vulnerability_to_line": 72,
          "vulnerability_code": "    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n\n        // Check the signature length\n\n        if (signature.length != 65) {\n\n            revert(\"ECDSA: invalid signature length\");\n\n        }\n\n\n\n        // Divide the signature in r, s and v variables\n\n        bytes32 r;\n\n        bytes32 s;\n\n        uint8 v;\n\n\n\n        // ecrecover takes the signature parameters, and the only way to get them\n\n        // currently is to use assembly.\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly {\n\n            r := mload(add(signature, 0x20))\n\n            s := mload(add(signature, 0x40))\n\n            v := byte(0, mload(add(signature, 0x60)))\n\n        }\n\n\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\n\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n\n        //\n\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n\n        // these malleable signatures as well.\n\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n\n            revert(\"ECDSA: invalid signature 's' value\");\n\n        }\n\n\n\n        if (v != 27 && v != 28) {\n\n            revert(\"ECDSA: invalid signature 'v' value\");\n\n        }\n\n\n\n        // If the signature is valid (and not malleable), return the signer address\n\n        address signer = ecrecover(hash, v, r, s);\n\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n\n\n        return signer;\n\n    }\n\n\n",
          "message": "ECDSA.recover uses assembly (ECDSA.sol#28-72)\n\t- ECDSA.sol#42-46\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 5,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.6.0;\n",
          "message": "Detected issues with version pragma in ECDSA.sol:\n\t- pragma solidity^0.6.0 (ECDSA.sol#5): it allows old versions\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 5,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.6.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 30,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (signature.length != 65) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 57,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_REVERT_REQUIRE",
          "vulnerability_from_line": 61,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (v != 27 && v != 28) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 28,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 42,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}