{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 209,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < names.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "inefficient-state-variable-increment",
          "vulnerability_from_line": 187,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _guardCounter += 1;\n",
          "message": "<x> += <y> costs more gas than <x> = <x> + <y> for state variables."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 10,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _owner) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 11,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_owner != address(0), \"Owner address cannot be 0\");\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 12,
          "vulnerability_to_line": null,
          "vulnerability_code": "        owner = _owner;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 13,
          "vulnerability_to_line": null,
          "vulnerability_code": "        emit OwnerChanged(address(0), _owner);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 14,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 52,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _owner) public Owned(_owner) {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 53,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_owner != address(0), \"Owner must not be zero\");\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 54,
          "vulnerability_to_line": null,
          "vulnerability_code": "        selfDestructBeneficiary = _owner;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "        emit SelfDestructBeneficiaryUpdated(_owner);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 56,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 122,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _owner) public Owned(_owner) {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 123,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // Paused will be false, and lastPauseTime will be 0 upon initialisation\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 124,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 173,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor() internal {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 174,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // The counter starts at one to prevent changing it from zero to a non-zero\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 175,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // value, which is a more expensive operation.\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 176,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _guardCounter = 1;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 177,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 202,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _owner) public Owned(_owner) {}\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 235,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _owner, address _resolver) public Owned(_owner) {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 236,
          "vulnerability_to_line": null,
          "vulnerability_code": "        resolver = AddressResolver(_resolver);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 237,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 614,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 615,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // Ownable\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 616,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _owner,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 617,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // Funds Wallet\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 618,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _fundsWallet,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 619,
          "vulnerability_to_line": null,
          "vulnerability_code": "        // Address Resolver\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 620,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _resolver\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 621,
          "vulnerability_to_line": null,
          "vulnerability_code": "    )\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 622,
          "vulnerability_to_line": null,
          "vulnerability_code": "        public\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 623,
          "vulnerability_to_line": null,
          "vulnerability_code": "        /* Owned is initialised in SelfDestructible */\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 210,
          "vulnerability_to_line": null,
          "vulnerability_code": "            repository[names[i]] = destinations[i];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 689,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = depositStartIndex; remainingToFulfill > 0 && i < depositEndIndex; i++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 689,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = depositStartIndex; remainingToFulfill > 0 && i < depositEndIndex; i++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 690,
          "vulnerability_to_line": null,
          "vulnerability_code": "            synthDeposit memory deposit = deposits[i];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 695,
          "vulnerability_to_line": null,
          "vulnerability_code": "                depositStartIndex = depositStartIndex.add(1);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 695,
          "vulnerability_to_line": null,
          "vulnerability_code": "                depositStartIndex = depositStartIndex.add(1);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 704,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    deposits[i] = synthDeposit({user: deposit.user, amount: newAmount});\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 706,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    totalSellableDeposits = totalSellableDeposits.sub(remainingToFulfill);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 706,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    totalSellableDeposits = totalSellableDeposits.sub(remainingToFulfill);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 720,
          "vulnerability_to_line": null,
          "vulnerability_code": "                        fundsWallet.transfer(ethToSend);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 738,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    delete deposits[i];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 740,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    depositStartIndex = depositStartIndex.add(1);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 740,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    depositStartIndex = depositStartIndex.add(1);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 742,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    totalSellableDeposits = totalSellableDeposits.sub(deposit.amount);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 742,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    totalSellableDeposits = totalSellableDeposits.sub(deposit.amount);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 756,
          "vulnerability_to_line": null,
          "vulnerability_code": "                        fundsWallet.transfer(ethToSend);\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 933,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = depositStartIndex; i < depositEndIndex; i++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 933,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = depositStartIndex; i < depositEndIndex; i++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 934,
          "vulnerability_to_line": null,
          "vulnerability_code": "            synthDeposit memory deposit = deposits[i];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 940,
          "vulnerability_to_line": null,
          "vulnerability_code": "                delete deposits[i];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 209,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < names.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 689,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = depositStartIndex; remainingToFulfill > 0 && i < depositEndIndex; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 933,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = depositStartIndex; i < depositEndIndex; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 11,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_owner != address(0), \"Owner address cannot be 0\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 22,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 29,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 53,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_owner != address(0), \"Owner must not be zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 64,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_beneficiary != address(0), \"Beneficiary must not be zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 96,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(selfDestructInitiated, \"Self Destruct not yet initiated\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 97,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(initiationTime + SELFDESTRUCT_DELAY < now, \"Self destruct delay not met\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 151,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!paused, \"This action cannot be performed while the contract is paused\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 207,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(names.length == destinations.length, \"Input lengths must match\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 653,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_amount > SafeDecimalMath.unit(), \"Minimum deposit amount must be greater than UNIT\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 680,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.value <= maxEthPurchase, \"ETH amount above maxEthPurchase limit\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 806,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(guaranteedRate == exchangeRates().rateForCurrency(ETH), \"Guaranteed rate would not be received\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 854,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(guaranteedEtherRate == exchangeRates().rateForCurrency(ETH), \"Guaranteed ether rate would not be received\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 855,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 856,
          "vulnerability_to_line": null,
          "vulnerability_code": "            guaranteedSynthetixRate == exchangeRates().rateForCurrency(SNX),\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 857,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"Guaranteed synthetix rate would not be received\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 858,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 905,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(guaranteedRate == exchangeRates().rateForCurrency(SNX), \"Guaranteed rate would not be received\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 955,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(synthsToSend > 0, \"You have no deposits to withdraw.\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1044,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!exchangeRates().rateIsInvalid(currencyKey), \"Rate stale or not a synth\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 209,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < names.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 689,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = depositStartIndex; remainingToFulfill > 0 && i < depositEndIndex; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 933,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = depositStartIndex; i < depositEndIndex; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 22,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 29,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 151,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(!paused, \"This action cannot be performed while the contract is paused\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 653,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_amount > SafeDecimalMath.unit(), \"Minimum deposit amount must be greater than UNIT\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 680,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.value <= maxEthPurchase, \"ETH amount above maxEthPurchase limit\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 806,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(guaranteedRate == exchangeRates().rateForCurrency(ETH), \"Guaranteed rate would not be received\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 854,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(guaranteedEtherRate == exchangeRates().rateForCurrency(ETH), \"Guaranteed ether rate would not be received\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 855,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 856,
          "vulnerability_to_line": null,
          "vulnerability_code": "            guaranteedSynthetixRate == exchangeRates().rateForCurrency(SNX),\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 857,
          "vulnerability_to_line": null,
          "vulnerability_code": "            \"Guaranteed synthetix rate would not be received\"\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 858,
          "vulnerability_to_line": null,
          "vulnerability_code": "        );\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 905,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(guaranteedRate == exchangeRates().rateForCurrency(SNX), \"Guaranteed rate would not be received\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 955,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(synthsToSend > 0, \"You have no deposits to withdraw.\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_49"
      ],
      "vulnerability_findings": [
        {
          "name": "unused-return",
          "vulnerability_from_line": 670,
          "vulnerability_to_line": 791,
          "vulnerability_code": "    function exchangeEtherForSynths()\n\n        public\n\n        payable\n\n        nonReentrant\n\n        rateNotInvalid(ETH)\n\n        notPaused\n\n        returns (\n\n            uint // Returns the number of Synths (sUSD) received\n\n        )\n\n    {\n\n        require(msg.value <= maxEthPurchase, \"ETH amount above maxEthPurchase limit\");\n\n        uint ethToSend;\n\n\n\n        // The multiplication works here because exchangeRates().rateForCurrency(ETH) is specified in\n\n        // 18 decimal places, just like our currency base.\n\n        uint requestedToPurchase = msg.value.multiplyDecimal(exchangeRates().rateForCurrency(ETH));\n\n        uint remainingToFulfill = requestedToPurchase;\n\n\n\n        // Iterate through our outstanding deposits and sell them one at a time.\n\n        for (uint i = depositStartIndex; remainingToFulfill > 0 && i < depositEndIndex; i++) {\n\n            synthDeposit memory deposit = deposits[i];\n\n\n\n            // If it's an empty spot in the queue from a previous withdrawal, just skip over it and\n\n            // update the queue. It's already been deleted.\n\n            if (deposit.user == address(0)) {\n\n                depositStartIndex = depositStartIndex.add(1);\n\n            } else {\n\n                // If the deposit can more than fill the order, we can do this\n\n                // without touching the structure of our queue.\n\n                if (deposit.amount > remainingToFulfill) {\n\n                    // Ok, this deposit can fulfill the whole remainder. We don't need\n\n                    // to change anything about our queue we can just fulfill it.\n\n                    // Subtract the amount from our deposit and total.\n\n                    uint newAmount = deposit.amount.sub(remainingToFulfill);\n\n                    deposits[i] = synthDeposit({user: deposit.user, amount: newAmount});\n\n\n\n                    totalSellableDeposits = totalSellableDeposits.sub(remainingToFulfill);\n\n\n\n                    // Transfer the ETH to the depositor. Send is used instead of transfer\n\n                    // so a non payable contract won't block the FIFO queue on a failed\n\n                    // ETH payable for synths transaction. The proceeds to be sent to the\n\n                    // synthetix foundation funds wallet. This is to protect all depositors\n\n                    // in the queue in this rare case that may occur.\n\n                    ethToSend = remainingToFulfill.divideDecimal(exchangeRates().rateForCurrency(ETH));\n\n\n\n                    // We need to use send here instead of transfer because transfer reverts\n\n                    // if the recipient is a non-payable contract. Send will just tell us it\n\n                    // failed by returning false at which point we can continue.\n\n                    // solium-disable-next-line security/no-send\n\n                    if (!deposit.user.send(ethToSend)) {\n\n                        fundsWallet.transfer(ethToSend);\n\n                        emit NonPayableContract(deposit.user, ethToSend);\n\n                    } else {\n\n                        emit ClearedDeposit(msg.sender, deposit.user, ethToSend, remainingToFulfill, i);\n\n                    }\n\n\n\n                    // And the Synths to the recipient.\n\n                    // Note: Fees are calculated by the Synth contract, so when\n\n                    //       we request a specific transfer here, the fee is\n\n                    //       automatically deducted and sent to the fee pool.\n\n                    synthsUSD().transfer(msg.sender, remainingToFulfill);\n\n\n\n                    // And we have nothing left to fulfill on this order.\n\n                    remainingToFulfill = 0;\n\n                } else if (deposit.amount <= remainingToFulfill) {\n\n                    // We need to fulfill this one in its entirety and kick it out of the queue.\n\n                    // Start by kicking it out of the queue.\n\n                    // Free the storage because we can.\n\n                    delete deposits[i];\n\n                    // Bump our start index forward one.\n\n                    depositStartIndex = depositStartIndex.add(1);\n\n                    // We also need to tell our total it's decreased\n\n                    totalSellableDeposits = totalSellableDeposits.sub(deposit.amount);\n\n\n\n                    // Now fulfill by transfering the ETH to the depositor. Send is used instead of transfer\n\n                    // so a non payable contract won't block the FIFO queue on a failed\n\n                    // ETH payable for synths transaction. The proceeds to be sent to the\n\n                    // synthetix foundation funds wallet. This is to protect all depositors\n\n                    // in the queue in this rare case that may occur.\n\n                    ethToSend = deposit.amount.divideDecimal(exchangeRates().rateForCurrency(ETH));\n\n\n\n                    // We need to use send here instead of transfer because transfer reverts\n\n                    // if the recipient is a non-payable contract. Send will just tell us it\n\n                    // failed by returning false at which point we can continue.\n\n                    // solium-disable-next-line security/no-send\n\n                    if (!deposit.user.send(ethToSend)) {\n\n                        fundsWallet.transfer(ethToSend);\n\n                        emit NonPayableContract(deposit.user, ethToSend);\n\n                    } else {\n\n                        emit ClearedDeposit(msg.sender, deposit.user, ethToSend, deposit.amount, i);\n\n                    }\n\n\n\n                    // And the Synths to the recipient.\n\n                    // Note: Fees are calculated by the Synth contract, so when\n\n                    //       we request a specific transfer here, the fee is\n\n                    //       automatically deducted and sent to the fee pool.\n\n                    synthsUSD().transfer(msg.sender, deposit.amount);\n\n\n\n                    // And subtract the order from our outstanding amount remaining\n\n                    // for the next iteration of the loop.\n\n                    remainingToFulfill = remainingToFulfill.sub(deposit.amount);\n\n                }\n\n            }\n\n        }\n\n\n\n        // Ok, if we're here and 'remainingToFulfill' isn't zero, then\n\n        // we need to refund the remainder of their ETH back to them.\n\n        if (remainingToFulfill > 0) {\n\n            msg.sender.transfer(remainingToFulfill.divideDecimal(exchangeRates().rateForCurrency(ETH)));\n\n        }\n\n\n\n        // How many did we actually give them?\n\n        uint fulfilled = requestedToPurchase.sub(remainingToFulfill);\n\n\n\n        if (fulfilled > 0) {\n\n            // Now tell everyone that we gave them that many (only if the amount is greater than 0).\n\n            emit Exchange(\"ETH\", msg.value, \"sUSD\", fulfilled);\n\n        }\n\n\n\n        return fulfilled;\n\n    }\n",
          "message": "Depot.exchangeEtherForSynths (Depot.sol#670-791) does not use the value returned by external calls:\n\t-synthsUSD().transfer(msg.sender,remainingToFulfill) (Depot.sol#730)\n\t-synthsUSD().transfer(msg.sender,deposit.amount) (Depot.sol#766)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 814,
          "vulnerability_to_line": 837,
          "vulnerability_code": "    function exchangeEtherForSNX()\n\n        public\n\n        payable\n\n        rateNotInvalid(SNX)\n\n        rateNotInvalid(ETH)\n\n        notPaused\n\n        returns (\n\n            uint // Returns the number of SNX received\n\n        )\n\n    {\n\n        // How many SNX are they going to be receiving?\n\n        uint synthetixToSend = synthetixReceivedForEther(msg.value);\n\n\n\n        // Store the ETH in our funds wallet\n\n        fundsWallet.transfer(msg.value);\n\n\n\n        // And send them the SNX.\n\n        synthetix().transfer(msg.sender, synthetixToSend);\n\n\n\n        emit Exchange(\"ETH\", msg.value, \"SNX\", synthetixToSend);\n\n\n\n        return synthetixToSend;\n\n    }\n",
          "message": "Depot.exchangeEtherForSNX (Depot.sol#814-837) does not use the value returned by external calls:\n\t-synthetix().transfer(msg.sender,synthetixToSend) (Depot.sol#831)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 867,
          "vulnerability_to_line": 890,
          "vulnerability_code": "    function exchangeSynthsForSNX(uint synthAmount)\n\n        public\n\n        rateNotInvalid(SNX)\n\n        notPaused\n\n        returns (\n\n            uint // Returns the number of SNX received\n\n        )\n\n    {\n\n        // How many SNX are they going to be receiving?\n\n        uint synthetixToSend = synthetixReceivedForSynths(synthAmount);\n\n\n\n        // Ok, transfer the Synths to our funds wallet.\n\n        // These do not go in the deposit queue as they aren't for sale as such unless\n\n        // they're sent back in from the funds wallet.\n\n        synthsUSD().transferFrom(msg.sender, fundsWallet, synthAmount);\n\n\n\n        // And send them the SNX.\n\n        synthetix().transfer(msg.sender, synthetixToSend);\n\n\n\n        emit Exchange(\"sUSD\", synthAmount, \"SNX\", synthetixToSend);\n\n\n\n        return synthetixToSend;\n\n    }\n",
          "message": "Depot.exchangeSynthsForSNX (Depot.sol#867-890) does not use the value returned by external calls:\n\t-synthsUSD().transferFrom(msg.sender,fundsWallet,synthAmount) (Depot.sol#881)\n\t-synthetix().transfer(msg.sender,synthetixToSend) (Depot.sol#884)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 914,
          "vulnerability_to_line": 922,
          "vulnerability_code": "    function withdrawSynthetix(uint amount) external onlyOwner {\n\n        synthetix().transfer(owner, amount);\n\n\n\n        // We don't emit our own events here because we assume that anyone\n\n        // who wants to watch what the Depot is doing can\n\n        // just watch ERC20 events from the Synth and/or Synthetix contracts\n\n        // filtered to our address.\n\n    }\n",
          "message": "Depot.withdrawSynthetix (Depot.sol#914-922) does not use the value returned by external calls:\n\t-synthetix().transfer(owner,amount) (Depot.sol#915)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 930,
          "vulnerability_to_line": 962,
          "vulnerability_code": "    function withdrawMyDepositedSynths() external {\n\n        uint synthsToSend = 0;\n\n\n\n        for (uint i = depositStartIndex; i < depositEndIndex; i++) {\n\n            synthDeposit memory deposit = deposits[i];\n\n\n\n            if (deposit.user == msg.sender) {\n\n                // The user is withdrawing this deposit. Remove it from our queue.\n\n                // We'll just leave a gap, which the purchasing logic can walk past.\n\n                synthsToSend = synthsToSend.add(deposit.amount);\n\n                delete deposits[i];\n\n                //Let the DApps know we've removed this deposit\n\n                emit SynthDepositRemoved(deposit.user, deposit.amount, i);\n\n            }\n\n        }\n\n\n\n        // Update our total\n\n        totalSellableDeposits = totalSellableDeposits.sub(synthsToSend);\n\n\n\n        // Check if the user has tried to send deposit amounts < the minimumDepositAmount to the FIFO\n\n        // queue which would have been added to this mapping for withdrawal only\n\n        synthsToSend = synthsToSend.add(smallDeposits[msg.sender]);\n\n        smallDeposits[msg.sender] = 0;\n\n\n\n        // If there's nothing to do then go ahead and revert the transaction\n\n        require(synthsToSend > 0, \"You have no deposits to withdraw.\");\n\n\n\n        // Send their deposits back to them (minus fees)\n\n        synthsUSD().transfer(msg.sender, synthsToSend);\n\n\n\n        emit SynthWithdrawal(msg.sender, synthsToSend);\n\n    }\n",
          "message": "Depot.withdrawMyDepositedSynths (Depot.sol#930-962) does not use the value returned by external calls:\n\t-synthsUSD().transfer(msg.sender,synthsToSend) (Depot.sol#958)\n"
        },
        {
          "name": "unused-return",
          "vulnerability_from_line": 967,
          "vulnerability_to_line": 991,
          "vulnerability_code": "    function depositSynths(uint amount) external {\n\n        // Grab the amount of synths. Will fail if not approved first\n\n        synthsUSD().transferFrom(msg.sender, this, amount);\n\n\n\n        // A minimum deposit amount is designed to protect purchasers from over paying\n\n        // gas for fullfilling multiple small synth deposits\n\n        if (amount < minimumDepositAmount) {\n\n            // We cant fail/revert the transaction or send the synths back in a reentrant call.\n\n            // So we will keep your synths balance seperate from the FIFO queue so you can withdraw them\n\n            smallDeposits[msg.sender] = smallDeposits[msg.sender].add(amount);\n\n\n\n            emit SynthDepositNotAccepted(msg.sender, amount, minimumDepositAmount);\n\n        } else {\n\n            // Ok, thanks for the deposit, let's queue it up.\n\n            deposits[depositEndIndex] = synthDeposit({user: msg.sender, amount: amount});\n\n            emit SynthDeposit(msg.sender, amount, depositEndIndex);\n\n\n\n            // Walk our index forward as well.\n\n            depositEndIndex = depositEndIndex.add(1);\n\n\n\n            // And add it to our total.\n\n            totalSellableDeposits = totalSellableDeposits.add(amount);\n\n        }\n\n    }\n",
          "message": "Depot.depositSynths (Depot.sol#967-991) does not use the value returned by external calls:\n\t-synthsUSD().transferFrom(msg.sender,this,amount) (Depot.sol#969)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 713,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    ethToSend = remainingToFulfill.divideDecimal(exchangeRates().rateForCurrency(ETH));\n",
          "message": "Depot.exchangeEtherForSynths has external calls inside a loop:\n\t- ethToSend = remainingToFulfill.divideDecimal(exchangeRates().rateForCurrency(ETH)) (Depot.sol#713)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 719,
          "vulnerability_to_line": 725,
          "vulnerability_code": "                    if (!deposit.user.send(ethToSend)) {\n\n                        fundsWallet.transfer(ethToSend);\n\n                        emit NonPayableContract(deposit.user, ethToSend);\n\n                    } else {\n\n                        emit ClearedDeposit(msg.sender, deposit.user, ethToSend, remainingToFulfill, i);\n\n                    }\n",
          "message": "Depot.exchangeEtherForSynths has external calls inside a loop:\n\t- ! deposit.user.send(ethToSend) (Depot.sol#719-725)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 720,
          "vulnerability_to_line": null,
          "vulnerability_code": "                        fundsWallet.transfer(ethToSend);\n",
          "message": "Depot.exchangeEtherForSynths has external calls inside a loop:\n\t- fundsWallet.transfer(ethToSend) (Depot.sol#720)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 730,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    synthsUSD().transfer(msg.sender, remainingToFulfill);\n",
          "message": "Depot.exchangeEtherForSynths has external calls inside a loop:\n\t- synthsUSD().transfer(msg.sender,remainingToFulfill) (Depot.sol#730)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 749,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    ethToSend = deposit.amount.divideDecimal(exchangeRates().rateForCurrency(ETH));\n",
          "message": "Depot.exchangeEtherForSynths has external calls inside a loop:\n\t- ethToSend = deposit.amount.divideDecimal(exchangeRates().rateForCurrency(ETH)) (Depot.sol#749)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 755,
          "vulnerability_to_line": 761,
          "vulnerability_code": "                    if (!deposit.user.send(ethToSend)) {\n\n                        fundsWallet.transfer(ethToSend);\n\n                        emit NonPayableContract(deposit.user, ethToSend);\n\n                    } else {\n\n                        emit ClearedDeposit(msg.sender, deposit.user, ethToSend, deposit.amount, i);\n\n                    }\n",
          "message": "Depot.exchangeEtherForSynths has external calls inside a loop:\n\t- ! deposit.user.send(ethToSend) (Depot.sol#755-761)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 756,
          "vulnerability_to_line": null,
          "vulnerability_code": "                        fundsWallet.transfer(ethToSend);\n",
          "message": "Depot.exchangeEtherForSynths has external calls inside a loop:\n\t- fundsWallet.transfer(ethToSend) (Depot.sol#756)\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 766,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    synthsUSD().transfer(msg.sender, deposit.amount);\n",
          "message": "Depot.exchangeEtherForSynths has external calls inside a loop:\n\t- synthsUSD().transfer(msg.sender,deposit.amount) (Depot.sol#766)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 967,
          "vulnerability_to_line": 991,
          "vulnerability_code": "    function depositSynths(uint amount) external {\n\n        // Grab the amount of synths. Will fail if not approved first\n\n        synthsUSD().transferFrom(msg.sender, this, amount);\n\n\n\n        // A minimum deposit amount is designed to protect purchasers from over paying\n\n        // gas for fullfilling multiple small synth deposits\n\n        if (amount < minimumDepositAmount) {\n\n            // We cant fail/revert the transaction or send the synths back in a reentrant call.\n\n            // So we will keep your synths balance seperate from the FIFO queue so you can withdraw them\n\n            smallDeposits[msg.sender] = smallDeposits[msg.sender].add(amount);\n\n\n\n            emit SynthDepositNotAccepted(msg.sender, amount, minimumDepositAmount);\n\n        } else {\n\n            // Ok, thanks for the deposit, let's queue it up.\n\n            deposits[depositEndIndex] = synthDeposit({user: msg.sender, amount: amount});\n\n            emit SynthDeposit(msg.sender, amount, depositEndIndex);\n\n\n\n            // Walk our index forward as well.\n\n            depositEndIndex = depositEndIndex.add(1);\n\n\n\n            // And add it to our total.\n\n            totalSellableDeposits = totalSellableDeposits.add(amount);\n\n        }\n\n    }\n",
          "message": "Reentrancy in Depot.depositSynths (Depot.sol#967-991):\n\tExternal calls:\n\t- synthsUSD().transferFrom(msg.sender,this,amount) (Depot.sol#969)\n\tState variables written after the call(s):\n\t- depositEndIndex (Depot.sol#985)\n\t- deposits (Depot.sol#981)\n\t- smallDeposits (Depot.sol#976)\n\t- totalSellableDeposits (Depot.sol#988)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 670,
          "vulnerability_to_line": 791,
          "vulnerability_code": "    function exchangeEtherForSynths()\n\n        public\n\n        payable\n\n        nonReentrant\n\n        rateNotInvalid(ETH)\n\n        notPaused\n\n        returns (\n\n            uint // Returns the number of Synths (sUSD) received\n\n        )\n\n    {\n\n        require(msg.value <= maxEthPurchase, \"ETH amount above maxEthPurchase limit\");\n\n        uint ethToSend;\n\n\n\n        // The multiplication works here because exchangeRates().rateForCurrency(ETH) is specified in\n\n        // 18 decimal places, just like our currency base.\n\n        uint requestedToPurchase = msg.value.multiplyDecimal(exchangeRates().rateForCurrency(ETH));\n\n        uint remainingToFulfill = requestedToPurchase;\n\n\n\n        // Iterate through our outstanding deposits and sell them one at a time.\n\n        for (uint i = depositStartIndex; remainingToFulfill > 0 && i < depositEndIndex; i++) {\n\n            synthDeposit memory deposit = deposits[i];\n\n\n\n            // If it's an empty spot in the queue from a previous withdrawal, just skip over it and\n\n            // update the queue. It's already been deleted.\n\n            if (deposit.user == address(0)) {\n\n                depositStartIndex = depositStartIndex.add(1);\n\n            } else {\n\n                // If the deposit can more than fill the order, we can do this\n\n                // without touching the structure of our queue.\n\n                if (deposit.amount > remainingToFulfill) {\n\n                    // Ok, this deposit can fulfill the whole remainder. We don't need\n\n                    // to change anything about our queue we can just fulfill it.\n\n                    // Subtract the amount from our deposit and total.\n\n                    uint newAmount = deposit.amount.sub(remainingToFulfill);\n\n                    deposits[i] = synthDeposit({user: deposit.user, amount: newAmount});\n\n\n\n                    totalSellableDeposits = totalSellableDeposits.sub(remainingToFulfill);\n\n\n\n                    // Transfer the ETH to the depositor. Send is used instead of transfer\n\n                    // so a non payable contract won't block the FIFO queue on a failed\n\n                    // ETH payable for synths transaction. The proceeds to be sent to the\n\n                    // synthetix foundation funds wallet. This is to protect all depositors\n\n                    // in the queue in this rare case that may occur.\n\n                    ethToSend = remainingToFulfill.divideDecimal(exchangeRates().rateForCurrency(ETH));\n\n\n\n                    // We need to use send here instead of transfer because transfer reverts\n\n                    // if the recipient is a non-payable contract. Send will just tell us it\n\n                    // failed by returning false at which point we can continue.\n\n                    // solium-disable-next-line security/no-send\n\n                    if (!deposit.user.send(ethToSend)) {\n\n                        fundsWallet.transfer(ethToSend);\n\n                        emit NonPayableContract(deposit.user, ethToSend);\n\n                    } else {\n\n                        emit ClearedDeposit(msg.sender, deposit.user, ethToSend, remainingToFulfill, i);\n\n                    }\n\n\n\n                    // And the Synths to the recipient.\n\n                    // Note: Fees are calculated by the Synth contract, so when\n\n                    //       we request a specific transfer here, the fee is\n\n                    //       automatically deducted and sent to the fee pool.\n\n                    synthsUSD().transfer(msg.sender, remainingToFulfill);\n\n\n\n                    // And we have nothing left to fulfill on this order.\n\n                    remainingToFulfill = 0;\n\n                } else if (deposit.amount <= remainingToFulfill) {\n\n                    // We need to fulfill this one in its entirety and kick it out of the queue.\n\n                    // Start by kicking it out of the queue.\n\n                    // Free the storage because we can.\n\n                    delete deposits[i];\n\n                    // Bump our start index forward one.\n\n                    depositStartIndex = depositStartIndex.add(1);\n\n                    // We also need to tell our total it's decreased\n\n                    totalSellableDeposits = totalSellableDeposits.sub(deposit.amount);\n\n\n\n                    // Now fulfill by transfering the ETH to the depositor. Send is used instead of transfer\n\n                    // so a non payable contract won't block the FIFO queue on a failed\n\n                    // ETH payable for synths transaction. The proceeds to be sent to the\n\n                    // synthetix foundation funds wallet. This is to protect all depositors\n\n                    // in the queue in this rare case that may occur.\n\n                    ethToSend = deposit.amount.divideDecimal(exchangeRates().rateForCurrency(ETH));\n\n\n\n                    // We need to use send here instead of transfer because transfer reverts\n\n                    // if the recipient is a non-payable contract. Send will just tell us it\n\n                    // failed by returning false at which point we can continue.\n\n                    // solium-disable-next-line security/no-send\n\n                    if (!deposit.user.send(ethToSend)) {\n\n                        fundsWallet.transfer(ethToSend);\n\n                        emit NonPayableContract(deposit.user, ethToSend);\n\n                    } else {\n\n                        emit ClearedDeposit(msg.sender, deposit.user, ethToSend, deposit.amount, i);\n\n                    }\n\n\n\n                    // And the Synths to the recipient.\n\n                    // Note: Fees are calculated by the Synth contract, so when\n\n                    //       we request a specific transfer here, the fee is\n\n                    //       automatically deducted and sent to the fee pool.\n\n                    synthsUSD().transfer(msg.sender, deposit.amount);\n\n\n\n                    // And subtract the order from our outstanding amount remaining\n\n                    // for the next iteration of the loop.\n\n                    remainingToFulfill = remainingToFulfill.sub(deposit.amount);\n\n                }\n\n            }\n\n        }\n\n\n\n        // Ok, if we're here and 'remainingToFulfill' isn't zero, then\n\n        // we need to refund the remainder of their ETH back to them.\n\n        if (remainingToFulfill > 0) {\n\n            msg.sender.transfer(remainingToFulfill.divideDecimal(exchangeRates().rateForCurrency(ETH)));\n\n        }\n\n\n\n        // How many did we actually give them?\n\n        uint fulfilled = requestedToPurchase.sub(remainingToFulfill);\n\n\n\n        if (fulfilled > 0) {\n\n            // Now tell everyone that we gave them that many (only if the amount is greater than 0).\n\n            emit Exchange(\"ETH\", msg.value, \"sUSD\", fulfilled);\n\n        }\n\n\n\n        return fulfilled;\n\n    }\n",
          "message": "Reentrancy in Depot.exchangeEtherForSynths (Depot.sol#670-791):\n\tExternal calls:\n\t- requestedToPurchase = msg.value.multiplyDecimal(exchangeRates().rateForCurrency(ETH)) (Depot.sol#685)\n\tState variables written after the call(s):\n\t- depositStartIndex (Depot.sol#695)\n\t- depositStartIndex (Depot.sol#740)\n\t- deposits (Depot.sol#704)\n\t- deposits (Depot.sol#738)\n\t- totalSellableDeposits (Depot.sol#706)\n\t- totalSellableDeposits (Depot.sol#742)\n"
        },
        {
          "name": "pragma",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity 0.4.25;\n",
          "message": "Different versions of Solidity is used in Depot.sol:\n\t- Version used: ['0.4.25', '^0.4.24']\n\t- Depot.sol#3 declares pragma solidity0.4.25\n\t- Depot.sol#39 declares pragma solidity0.4.25\n\t- Depot.sol#111 declares pragma solidity0.4.25\n\t- Depot.sol#160 declares pragma solidity^0.4.24\n\t- Depot.sol#196-197 declares pragma solidity0.4.25\n\t- Depot.sol#229-230 declares pragma solidity0.4.25\n\t- Depot.sol#250-251 declares pragma solidity^0.4.24\n\t- Depot.sol#318-319 declares pragma solidity0.4.25\n\t- Depot.sol#505-506 declares pragma solidity0.4.25\n\t- Depot.sol#539-540 declares pragma solidity0.4.25\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 206,
          "vulnerability_to_line": 213,
          "vulnerability_code": "    function importAddresses(bytes32[] names, address[] destinations) public onlyOwner {\n\n        require(names.length == destinations.length, \"Input lengths must match\");\n\n\n\n        for (uint i = 0; i < names.length; i++) {\n\n            repository[names[i]] = destinations[i];\n\n        }\n\n    }\n",
          "message": "AddressResolver.importAddresses (Depot.sol#206-213) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 216,
          "vulnerability_to_line": 219,
          "vulnerability_code": "    function getAddress(bytes32 name) public view returns (address) {\n\n        return repository[name];\n\n    }\n",
          "message": "AddressResolver.getAddress (Depot.sol#216-219) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 220,
          "vulnerability_to_line": 225,
          "vulnerability_code": "    function requireAndGetAddress(bytes32 name, string reason) public view returns (address) {\n\n        address _foundAddress = repository[name];\n\n        require(_foundAddress != address(0), reason);\n\n        return _foundAddress;\n\n    }\n",
          "message": "AddressResolver.requireAndGetAddress (Depot.sol#220-225) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": 244,
          "vulnerability_code": "    function setResolver(AddressResolver _resolver) public onlyOwner {\n\n        resolver = _resolver;\n\n    }\n",
          "message": "MixinResolver.setResolver (Depot.sol#241-244) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 509,
          "vulnerability_to_line": 510,
          "vulnerability_code": "    function totalSupply() public view returns (uint);\n",
          "message": "IERC20.totalSupply (Depot.sol#509-510) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 511,
          "vulnerability_to_line": 512,
          "vulnerability_code": "    function balanceOf(address owner) public view returns (uint);\n",
          "message": "IERC20.balanceOf (Depot.sol#511-512) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 513,
          "vulnerability_to_line": 514,
          "vulnerability_code": "    function allowance(address owner, address spender) public view returns (uint);\n",
          "message": "IERC20.allowance (Depot.sol#513-514) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 515,
          "vulnerability_to_line": 516,
          "vulnerability_code": "    function transfer(address to, uint value) public returns (bool);\n",
          "message": "IERC20.transfer (Depot.sol#515-516) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 517,
          "vulnerability_to_line": 518,
          "vulnerability_code": "    function approve(address spender, uint value) public returns (bool);\n",
          "message": "IERC20.approve (Depot.sol#517-518) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 519,
          "vulnerability_to_line": 524,
          "vulnerability_code": "    function transferFrom(\n\n        address from,\n\n        address to,\n\n        uint value\n\n    ) public returns (bool);\n",
          "message": "IERC20.transferFrom (Depot.sol#519-524) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 526,
          "vulnerability_to_line": 527,
          "vulnerability_code": "    function name() public view returns (string);\n",
          "message": "IERC20.name (Depot.sol#526-527) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 528,
          "vulnerability_to_line": 529,
          "vulnerability_code": "    function symbol() public view returns (string);\n",
          "message": "IERC20.symbol (Depot.sol#528-529) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 530,
          "vulnerability_to_line": 531,
          "vulnerability_code": "    function decimals() public view returns (uint8);\n",
          "message": "IERC20.decimals (Depot.sol#530-531) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 797,
          "vulnerability_to_line": 810,
          "vulnerability_code": "    function exchangeEtherForSynthsAtRate(uint guaranteedRate)\n\n        public\n\n        payable\n\n        rateNotInvalid(ETH)\n\n        notPaused\n\n        returns (\n\n            uint // Returns the number of Synths (sUSD) received\n\n        )\n\n    {\n\n        require(guaranteedRate == exchangeRates().rateForCurrency(ETH), \"Guaranteed rate would not be received\");\n\n\n\n        return exchangeEtherForSynths();\n\n    }\n",
          "message": "Depot.exchangeEtherForSynthsAtRate (Depot.sol#797-810) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 844,
          "vulnerability_to_line": 862,
          "vulnerability_code": "    function exchangeEtherForSNXAtRate(uint guaranteedEtherRate, uint guaranteedSynthetixRate)\n\n        public\n\n        payable\n\n        rateNotInvalid(SNX)\n\n        rateNotInvalid(ETH)\n\n        notPaused\n\n        returns (\n\n            uint // Returns the number of SNX received\n\n        )\n\n    {\n\n        require(guaranteedEtherRate == exchangeRates().rateForCurrency(ETH), \"Guaranteed ether rate would not be received\");\n\n        require(\n\n            guaranteedSynthetixRate == exchangeRates().rateForCurrency(SNX),\n\n            \"Guaranteed synthetix rate would not be received\"\n\n        );\n\n\n\n        return exchangeEtherForSNX();\n\n    }\n",
          "message": "Depot.exchangeEtherForSNXAtRate (Depot.sol#844-862) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 897,
          "vulnerability_to_line": 909,
          "vulnerability_code": "    function exchangeSynthsForSNXAtRate(uint synthAmount, uint guaranteedRate)\n\n        public\n\n        rateNotInvalid(SNX)\n\n        notPaused\n\n        returns (\n\n            uint // Returns the number of SNX received\n\n        )\n\n    {\n\n        require(guaranteedRate == exchangeRates().rateForCurrency(SNX), \"Guaranteed rate would not be received\");\n\n\n\n        return exchangeSynthsForSNX(synthAmount);\n\n    }\n",
          "message": "Depot.exchangeSynthsForSNXAtRate (Depot.sol#897-909) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1022,
          "vulnerability_to_line": 1026,
          "vulnerability_code": "    function synthsReceivedForEther(uint amount) public view returns (uint) {\n\n        // How many synths would that amount of ether be worth?\n\n        return amount.multiplyDecimal(exchangeRates().rateForCurrency(ETH));\n\n    }\n",
          "message": "Depot.synthsReceivedForEther (Depot.sol#1022-1026) should be declared external\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 10,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _owner) public {\n",
          "message": "Parameter '_owner' of Owned. (Depot.sol#10) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 16,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function nominateNewOwner(address _owner) external onlyOwner {\n",
          "message": "Parameter '_owner' of Owned.nominateNewOwner (Depot.sol#16) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 52,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _owner) public Owned(_owner) {\n",
          "message": "Parameter '_owner' of SelfDestructible. (Depot.sol#52) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setSelfDestructBeneficiary(address _beneficiary) external onlyOwner {\n",
          "message": "Parameter '_beneficiary' of SelfDestructible.setSelfDestructBeneficiary (Depot.sol#63) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 130,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setPaused(bool _paused) external onlyOwner {\n",
          "message": "Parameter '_paused' of Pausable.setPaused (Depot.sol#130) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 235,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _owner, address _resolver) public Owned(_owner) {\n",
          "message": "Parameter '_resolver' of MixinResolver. (Depot.sol#235) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setResolver(AddressResolver _resolver) public onlyOwner {\n",
          "message": "Parameter '_resolver' of MixinResolver.setResolver (Depot.sol#241) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 375,
          "vulnerability_to_line": 389,
          "vulnerability_code": "    function _multiplyDecimalRound(\n\n        uint x,\n\n        uint y,\n\n        uint precisionUnit\n\n    ) private pure returns (uint) {\n\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n\n\n        if (quotientTimesTen % 10 >= 5) {\n\n            quotientTimesTen += 10;\n\n        }\n\n\n\n        return quotientTimesTen / 10;\n\n    }\n",
          "message": "Function 'SafeDecimalMath._multiplyDecimalRound' (Depot.sol#375-389) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 444,
          "vulnerability_to_line": 457,
          "vulnerability_code": "    function _divideDecimalRound(\n\n        uint x,\n\n        uint y,\n\n        uint precisionUnit\n\n    ) private pure returns (uint) {\n\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n\n\n        if (resultTimesTen % 10 >= 5) {\n\n            resultTimesTen += 10;\n\n        }\n\n\n\n        return resultTimesTen / 10;\n\n    }\n",
          "message": "Function 'SafeDecimalMath._divideDecimalRound' (Depot.sol#444-457) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 326,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint8 public constant highPrecisionDecimals = 27;\n",
          "message": "Constant 'SafeDecimalMath.highPrecisionDecimals' (Depot.sol#326) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 572,
          "vulnerability_to_line": 578,
          "vulnerability_code": "    struct synthDeposit {\n\n        // The user that made the deposit\n\n        address user;\n\n        // The amount (in Synths) that they deposited\n\n        uint amount;\n\n    }\n",
          "message": "Struct 'Depot.synthDeposit' (Depot.sol#572-578) is not in CapWords\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 618,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address _fundsWallet,\n",
          "message": "Parameter '_fundsWallet' of Depot. (Depot.sol#618) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 633,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setMaxEthPurchase(uint _maxEthPurchase) external onlyOwner {\n",
          "message": "Parameter '_maxEthPurchase' of Depot.setMaxEthPurchase (Depot.sol#633) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 642,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setFundsWallet(address _fundsWallet) external onlyOwner {\n",
          "message": "Parameter '_fundsWallet' of Depot.setFundsWallet (Depot.sol#642) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 651,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setMinimumDepositAmount(uint _amount) external onlyOwner {\n",
          "message": "Parameter '_amount' of Depot.setMinimumDepositAmount (Depot.sol#651) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 25,
          "vulnerability_to_line": null,
          "vulnerability_code": "        nominatedOwner = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 209,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < names.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 689,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = depositStartIndex; remainingToFulfill > 0 && i < depositEndIndex; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 933,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = depositStartIndex; i < depositEndIndex; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 209,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = 0; i < names.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 63,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setSelfDestructBeneficiary(address _beneficiary) external onlyOwner {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 130,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setPaused(bool _paused) external onlyOwner {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 241,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setResolver(AddressResolver _resolver) public onlyOwner {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 633,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setMaxEthPurchase(uint _maxEthPurchase) external onlyOwner {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 642,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setFundsWallet(address _fundsWallet) external onlyOwner {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 651,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setMinimumDepositAmount(uint _amount) external onlyOwner {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 160,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 250,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 171,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 private _guardCounter;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 333,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 322,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 558,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_TRANSFER_IN_LOOP",
          "vulnerability_from_line": 689,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint i = depositStartIndex; remainingToFulfill > 0 && i < depositEndIndex; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 206,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function importAddresses(bytes32[] names, address[] destinations) public onlyOwner {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 206,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function importAddresses(bytes32[] names, address[] destinations) public onlyOwner {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 220,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function requireAndGetAddress(bytes32 name, string reason) public view returns (address) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 526,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function name() public view returns (string);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UPGRADE_TO_050",
          "vulnerability_from_line": 528,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function symbol() public view returns (string);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 561,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 constant SNX = \"SNX\";\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 562,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 constant ETH = \"ETH\";\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 206,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function importAddresses(bytes32[] names, address[] destinations) public onlyOwner {\n",
          "message": null
        },
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 590,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(uint => synthDeposit) public deposits;\n",
          "message": null
        },
        {
          "name": "Timestamp Dependency",
          "vulnerability_from_line": 97,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(initiationTime + SELFDESTRUCT_DELAY < now, \"Self destruct delay not met\");\n",
          "message": null
        },
        {
          "name": "Timestamp Dependency",
          "vulnerability_from_line": 97,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(initiationTime + SELFDESTRUCT_DELAY < now, \"Self destruct delay not met\");\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Unprotected Selfdestruct (SWC 106)",
          "vulnerability_from_line": 100,
          "vulnerability_to_line": null,
          "vulnerability_code": "        selfdestruct(beneficiary);\n",
          "message": "Any sender can cause the contract to self-destruct.\nAny sender can trigger execution of the SELFDESTRUCT instruction to destroy this contract account and withdraw its balance to an arbitrary address. Review the transaction trace generated for this issue and make sure that appropriate security controls are in place to prevent unrestricted access.\nClassification: SWC-106"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 97,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(initiationTime + SELFDESTRUCT_DELAY < now, \"Self destruct delay not met\");\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 187,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _guardCounter += 1;\n",
          "message": null
        },
        {
          "name": "Time dependency bug",
          "vulnerability_from_line": 97,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(initiationTime + SELFDESTRUCT_DELAY < now, \"Self destruct delay not met\");\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 97,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(initiationTime + SELFDESTRUCT_DELAY < now, \"Self destruct delay not met\");\n",
          "message": null
        },
        {
          "name": "Time dependency bug",
          "vulnerability_from_line": 97,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(initiationTime + SELFDESTRUCT_DELAY < now, \"Self destruct delay not met\");\n",
          "message": null
        }
      ]
    }
  }
}