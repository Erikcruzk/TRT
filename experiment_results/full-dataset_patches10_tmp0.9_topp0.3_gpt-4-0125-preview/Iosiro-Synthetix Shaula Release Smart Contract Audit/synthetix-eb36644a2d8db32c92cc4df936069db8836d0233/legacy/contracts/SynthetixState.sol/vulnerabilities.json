{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 489,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint8 i = 0; i < accounts.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 10,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _owner) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 11,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_owner != address(0), \"Owner address cannot be 0\");\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 12,
          "vulnerability_to_line": null,
          "vulnerability_code": "        owner = _owner;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 13,
          "vulnerability_to_line": null,
          "vulnerability_code": "        emit OwnerChanged(address(0), _owner);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 14,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 44,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _owner, address _associatedContract) public Owned(_owner) {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 45,
          "vulnerability_to_line": null,
          "vulnerability_code": "        associatedContract = _associatedContract;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 46,
          "vulnerability_to_line": null,
          "vulnerability_code": "        emit AssociatedContractUpdated(_associatedContract);\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 47,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 75,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(uint setupDuration) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 76,
          "vulnerability_to_line": null,
          "vulnerability_code": "        setupExpiryTime = now + setupDuration;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 77,
          "vulnerability_to_line": null,
          "vulnerability_code": "    }\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 409,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _owner, address _associatedContract)\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 410,
          "vulnerability_to_line": null,
          "vulnerability_code": "        public\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 411,
          "vulnerability_to_line": null,
          "vulnerability_code": "        State(_owner, _associatedContract)\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 412,
          "vulnerability_to_line": null,
          "vulnerability_code": "        LimitedSetup(1 weeks)\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 413,
          "vulnerability_to_line": null,
          "vulnerability_code": "    {}\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 489,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint8 i = 0; i < accounts.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 11,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_owner != address(0), \"Owner address cannot be 0\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 22,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 29,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == associatedContract, \"Only the associated contract can perform this action\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(now < setupExpiryTime, \"Can only perform this action during setup\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 477,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_issuanceRatio <= MAX_ISSUANCE_RATIO, \"New issuance ratio cannot exceed MAX_ISSUANCE_RATIO\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 487,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(accounts.length == sUSDAmounts.length, \"Length mismatch\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 489,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint8 i = 0; i < accounts.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 22,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 29,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == associatedContract, \"Only the associated contract can perform this action\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 80,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(now < setupExpiryTime, \"Can only perform this action during setup\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 477,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_issuanceRatio <= MAX_ISSUANCE_RATIO, \"New issuance ratio cannot exceed MAX_ISSUANCE_RATIO\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_12"
      ],
      "vulnerability_findings": [
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 498,
          "vulnerability_to_line": 547,
          "vulnerability_code": "    function _addToDebtRegister(address account, uint amount) internal {\n\n        // This code is duplicated from Synthetix so that we can call it directly here\n\n        // during setup only.\n\n        Synthetix synthetix = Synthetix(associatedContract);\n\n\n\n        // What is the value of the requested debt in XDRs?\n\n        uint xdrValue = synthetix.effectiveValue(\"sUSD\", amount, \"XDR\");\n\n\n\n        // What is the value that we've previously imported?\n\n        uint totalDebtIssued = importedXDRAmount;\n\n\n\n        // What will the new total be including the new value?\n\n        uint newTotalDebtIssued = xdrValue.add(totalDebtIssued);\n\n\n\n        // Save that for the next import.\n\n        importedXDRAmount = newTotalDebtIssued;\n\n\n\n        // What is their percentage (as a high precision int) of the total debt?\n\n        uint debtPercentage = xdrValue.divideDecimalRoundPrecise(newTotalDebtIssued);\n\n\n\n        // And what effect does this percentage have on the global debt holding of other issuers?\n\n        // The delta specifically needs to not take into account any existing debt as it's already\n\n        // accounted for in the delta from when they issued previously.\n\n        // The delta is a high precision integer.\n\n        uint delta = SafeDecimalMath.preciseUnit().sub(debtPercentage);\n\n\n\n        uint existingDebt = synthetix.debtBalanceOf(account, \"XDR\");\n\n\n\n        // And what does their debt ownership look like including this previous stake?\n\n        if (existingDebt > 0) {\n\n            debtPercentage = xdrValue.add(existingDebt).divideDecimalRoundPrecise(newTotalDebtIssued);\n\n        }\n\n\n\n        // Are they a new issuer? If so, record them.\n\n        if (issuanceData[account].initialDebtOwnership == 0) {\n\n            totalIssuerCount = totalIssuerCount.add(1);\n\n        }\n\n\n\n        // Save the debt entry parameters\n\n        issuanceData[account].initialDebtOwnership = debtPercentage;\n\n        issuanceData[account].debtEntryIndex = debtLedger.length;\n\n\n\n        // And if we're the first, push 1 as there was no effect to any other holders, otherwise push\n\n        // the change for the rest of the debt holders. The debt ledger holds high precision integers.\n\n        if (debtLedger.length > 0) {\n\n            debtLedger.push(debtLedger[debtLedger.length - 1].multiplyDecimalRoundPrecise(delta));\n\n        } else {\n\n            debtLedger.push(SafeDecimalMath.preciseUnit());\n\n        }\n",
          "message": "Reentrancy in SynthetixState._addToDebtRegister (SynthetixState.sol#498-547):\n\tExternal calls:\n\t- xdrValue = synthetix.effectiveValue(sUSD,amount,XDR) (SynthetixState.sol#504)\n\tState variables written after the call(s):\n\t- importedXDRAmount (SynthetixState.sol#513)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 498,
          "vulnerability_to_line": 547,
          "vulnerability_code": "    function _addToDebtRegister(address account, uint amount) internal {\n\n        // This code is duplicated from Synthetix so that we can call it directly here\n\n        // during setup only.\n\n        Synthetix synthetix = Synthetix(associatedContract);\n\n\n\n        // What is the value of the requested debt in XDRs?\n\n        uint xdrValue = synthetix.effectiveValue(\"sUSD\", amount, \"XDR\");\n\n\n\n        // What is the value that we've previously imported?\n\n        uint totalDebtIssued = importedXDRAmount;\n\n\n\n        // What will the new total be including the new value?\n\n        uint newTotalDebtIssued = xdrValue.add(totalDebtIssued);\n\n\n\n        // Save that for the next import.\n\n        importedXDRAmount = newTotalDebtIssued;\n\n\n\n        // What is their percentage (as a high precision int) of the total debt?\n\n        uint debtPercentage = xdrValue.divideDecimalRoundPrecise(newTotalDebtIssued);\n\n\n\n        // And what effect does this percentage have on the global debt holding of other issuers?\n\n        // The delta specifically needs to not take into account any existing debt as it's already\n\n        // accounted for in the delta from when they issued previously.\n\n        // The delta is a high precision integer.\n\n        uint delta = SafeDecimalMath.preciseUnit().sub(debtPercentage);\n\n\n\n        uint existingDebt = synthetix.debtBalanceOf(account, \"XDR\");\n\n\n\n        // And what does their debt ownership look like including this previous stake?\n\n        if (existingDebt > 0) {\n\n            debtPercentage = xdrValue.add(existingDebt).divideDecimalRoundPrecise(newTotalDebtIssued);\n\n        }\n\n\n\n        // Are they a new issuer? If so, record them.\n\n        if (issuanceData[account].initialDebtOwnership == 0) {\n\n            totalIssuerCount = totalIssuerCount.add(1);\n\n        }\n\n\n\n        // Save the debt entry parameters\n\n        issuanceData[account].initialDebtOwnership = debtPercentage;\n\n        issuanceData[account].debtEntryIndex = debtLedger.length;\n\n\n\n        // And if we're the first, push 1 as there was no effect to any other holders, otherwise push\n\n        // the change for the rest of the debt holders. The debt ledger holds high precision integers.\n\n        if (debtLedger.length > 0) {\n\n            debtLedger.push(debtLedger[debtLedger.length - 1].multiplyDecimalRoundPrecise(delta));\n\n        } else {\n\n            debtLedger.push(SafeDecimalMath.preciseUnit());\n\n        }\n",
          "message": "Reentrancy in SynthetixState._addToDebtRegister (SynthetixState.sol#498-547):\n\tExternal calls:\n\t- xdrValue = synthetix.effectiveValue(sUSD,amount,XDR) (SynthetixState.sol#504)\n\t- existingDebt = synthetix.debtBalanceOf(account,XDR) (SynthetixState.sol#524)\n\tState variables written after the call(s):\n\t- debtLedger (SynthetixState.sol#543)\n\t- debtLedger (SynthetixState.sol#545)\n\t- issuanceData (SynthetixState.sol#537)\n\t- issuanceData (SynthetixState.sol#538)\n\t- totalIssuerCount (SynthetixState.sol#533)\n"
        },
        {
          "name": "pragma",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity 0.4.25;\n",
          "message": "Different versions of Solidity is used in SynthetixState.sol:\n\t- Version used: ['0.4.25', '^0.4.24']\n\t- SynthetixState.sol#3 declares pragma solidity0.4.25\n\t- SynthetixState.sol#39 declares pragma solidity0.4.25\n\t- SynthetixState.sol#64 declares pragma solidity0.4.25\n\t- SynthetixState.sol#89 declares pragma solidity^0.4.24\n\t- SynthetixState.sol#157 declares pragma solidity0.4.25\n\t- SynthetixState.sol#344 declares pragma solidity0.4.25\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 10,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _owner) public {\n",
          "message": "Parameter '_owner' of Owned. (SynthetixState.sol#10) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 16,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function nominateNewOwner(address _owner) external onlyOwner {\n",
          "message": "Parameter '_owner' of Owned.nominateNewOwner (SynthetixState.sol#16) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 44,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(address _owner, address _associatedContract) public Owned(_owner) {\n",
          "message": "Parameter '_associatedContract' of State. (SynthetixState.sol#44) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 49,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setAssociatedContract(address _associatedContract) external onlyOwner {\n",
          "message": "Parameter '_associatedContract' of State.setAssociatedContract (SynthetixState.sol#49) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 214,
          "vulnerability_to_line": 227,
          "vulnerability_code": "    function _multiplyDecimalRound(\n\n        uint x,\n\n        uint y,\n\n        uint precisionUnit\n\n    ) private pure returns (uint) {\n\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n\n\n        if (quotientTimesTen % 10 >= 5) {\n\n            quotientTimesTen += 10;\n\n        }\n\n\n\n        return quotientTimesTen / 10;\n",
          "message": "Function 'SafeDecimalMath._multiplyDecimalRound' (SynthetixState.sol#214-227) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 283,
          "vulnerability_to_line": 295,
          "vulnerability_code": "    function _divideDecimalRound(\n\n        uint x,\n\n        uint y,\n\n        uint precisionUnit\n\n    ) private pure returns (uint) {\n\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n\n\n        if (resultTimesTen % 10 >= 5) {\n\n            resultTimesTen += 10;\n\n        }\n\n\n\n        return resultTimesTen / 10;\n",
          "message": "Function 'SafeDecimalMath._divideDecimalRound' (SynthetixState.sol#283-295) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 165,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint8 public constant highPrecisionDecimals = 27;\n",
          "message": "Constant 'SafeDecimalMath.highPrecisionDecimals' (SynthetixState.sol#165) is not in UPPER_CASE_WITH_UNDERSCORES\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setIssuanceRatio(uint _issuanceRatio) external onlyOwner {\n",
          "message": "Parameter '_issuanceRatio' of SynthetixState.setIssuanceRatio (SynthetixState.sol#476) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 498,
          "vulnerability_to_line": 547,
          "vulnerability_code": "    function _addToDebtRegister(address account, uint amount) internal {\n\n        // This code is duplicated from Synthetix so that we can call it directly here\n\n        // during setup only.\n\n        Synthetix synthetix = Synthetix(associatedContract);\n\n\n\n        // What is the value of the requested debt in XDRs?\n\n        uint xdrValue = synthetix.effectiveValue(\"sUSD\", amount, \"XDR\");\n\n\n\n        // What is the value that we've previously imported?\n\n        uint totalDebtIssued = importedXDRAmount;\n\n\n\n        // What will the new total be including the new value?\n\n        uint newTotalDebtIssued = xdrValue.add(totalDebtIssued);\n\n\n\n        // Save that for the next import.\n\n        importedXDRAmount = newTotalDebtIssued;\n\n\n\n        // What is their percentage (as a high precision int) of the total debt?\n\n        uint debtPercentage = xdrValue.divideDecimalRoundPrecise(newTotalDebtIssued);\n\n\n\n        // And what effect does this percentage have on the global debt holding of other issuers?\n\n        // The delta specifically needs to not take into account any existing debt as it's already\n\n        // accounted for in the delta from when they issued previously.\n\n        // The delta is a high precision integer.\n\n        uint delta = SafeDecimalMath.preciseUnit().sub(debtPercentage);\n\n\n\n        uint existingDebt = synthetix.debtBalanceOf(account, \"XDR\");\n\n\n\n        // And what does their debt ownership look like including this previous stake?\n\n        if (existingDebt > 0) {\n\n            debtPercentage = xdrValue.add(existingDebt).divideDecimalRoundPrecise(newTotalDebtIssued);\n\n        }\n\n\n\n        // Are they a new issuer? If so, record them.\n\n        if (issuanceData[account].initialDebtOwnership == 0) {\n\n            totalIssuerCount = totalIssuerCount.add(1);\n\n        }\n\n\n\n        // Save the debt entry parameters\n\n        issuanceData[account].initialDebtOwnership = debtPercentage;\n\n        issuanceData[account].debtEntryIndex = debtLedger.length;\n\n\n\n        // And if we're the first, push 1 as there was no effect to any other holders, otherwise push\n\n        // the change for the rest of the debt holders. The debt ledger holds high precision integers.\n\n        if (debtLedger.length > 0) {\n\n            debtLedger.push(debtLedger[debtLedger.length - 1].multiplyDecimalRoundPrecise(delta));\n\n        } else {\n\n            debtLedger.push(SafeDecimalMath.preciseUnit());\n\n        }\n",
          "message": "Function 'SynthetixState._addToDebtRegister' (SynthetixState.sol#498-547) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 25,
          "vulnerability_to_line": null,
          "vulnerability_code": "        nominatedOwner = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 489,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint8 i = 0; i < accounts.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 489,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint8 i = 0; i < accounts.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 49,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setAssociatedContract(address _associatedContract) external onlyOwner {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 476,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setIssuanceRatio(uint _issuanceRatio) external onlyOwner {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 89,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.4.24;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 172,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 161,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 365,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 69,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint setupExpiryTime;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 398,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint constant MAX_ISSUANCE_RATIO = SafeDecimalMath.unit();\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 389,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint[] public debtLedger;\n",
          "message": null
        },
        {
          "name": "Integer Underflow",
          "vulnerability_from_line": 562,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return debtLedger[debtLedger.length - 1];\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Arithmetic Bugs (SWC 101)",
          "vulnerability_from_line": 76,
          "vulnerability_to_line": null,
          "vulnerability_code": "        setupExpiryTime = now + setupDuration;\n",
          "message": "The arithmetic operator can overflow.\nIt is possible to cause an integer overflow or underflow in the arithmetic operation. \nClassification: SWC-101"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 1,
          "vulnerability_to_line": null,
          "vulnerability_code": "// File: ../sc_datasets/DAppSCAN/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-eb36644a2d8db32c92cc4df936069db8836d0233/legacy/common/Owned.sol\n",
          "message": null
        },
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 402,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => bytes4) public preferredCurrency;\n",
          "message": null
        }
      ]
    }
  }
}