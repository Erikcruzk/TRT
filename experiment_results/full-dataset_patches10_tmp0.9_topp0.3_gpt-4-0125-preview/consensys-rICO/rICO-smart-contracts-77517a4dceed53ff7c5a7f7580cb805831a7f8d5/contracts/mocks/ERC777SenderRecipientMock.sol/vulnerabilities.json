{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 733,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _defaultOperatorsArray.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 724,
          "vulnerability_to_line": null,
          "vulnerability_code": "    constructor(\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 725,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string memory name,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 726,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string memory symbol,\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 727,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] memory defaultOperators\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 728,
          "vulnerability_to_line": null,
          "vulnerability_code": "    ) public {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 729,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _name = name;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 730,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _symbol = symbol;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 731,
          "vulnerability_to_line": null,
          "vulnerability_code": "\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 732,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _defaultOperatorsArray = defaultOperators;\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "non-payable-constructor",
          "vulnerability_from_line": 733,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _defaultOperatorsArray.length; i++) {\n",
          "message": "Consider making costructor payable to save gas."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 733,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _defaultOperatorsArray.length; i++) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 734,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _defaultOperators[_defaultOperatorsArray[i]] = true;\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 734,
          "vulnerability_to_line": null,
          "vulnerability_code": "            _defaultOperators[_defaultOperatorsArray[i]] = true;\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 733,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _defaultOperatorsArray.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 536,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c >= a, \"SafeMath: addition overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 551,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(b <= a, \"SafeMath: subtraction overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 575,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 593,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(b > 0, \"SafeMath: division by zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 612,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(b != 0, \"SafeMath: modulo by zero\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 807,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(recipient != address(0), \"ERC777: transfer to the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 845,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender != operator, \"ERC777: authorizing self as operator\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 860,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(operator != msg.sender, \"ERC777: revoking self as operator\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 892,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(isOperatorFor(msg.sender, sender), \"ERC777: caller is not an operator for holder\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 902,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(isOperatorFor(msg.sender, account), \"ERC777: caller is not an operator for holder\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 938,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(recipient != address(0), \"ERC777: transfer to the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 939,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(holder != address(0), \"ERC777: transfer from the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 979,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(account != address(0), \"ERC777: mint to the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1012,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(from != address(0), \"ERC777: send from the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1013,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(to != address(0), \"ERC777: send to the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1039,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(from != address(0), \"ERC777: burn from the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1072,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(spender != address(0), \"ERC777: approve to the zero address\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 1129,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(!to.isContract(), \"ERC777: token recipient contract has no implementer for ERC777TokensRecipient\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 733,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _defaultOperatorsArray.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 575,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(c / a == b, \"SafeMath: multiplication overflow\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 807,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(recipient != address(0), \"ERC777: transfer to the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 845,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender != operator, \"ERC777: authorizing self as operator\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 860,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(operator != msg.sender, \"ERC777: revoking self as operator\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 892,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(isOperatorFor(msg.sender, sender), \"ERC777: caller is not an operator for holder\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 902,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(isOperatorFor(msg.sender, account), \"ERC777: caller is not an operator for holder\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 938,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(recipient != address(0), \"ERC777: transfer to the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 939,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(holder != address(0), \"ERC777: transfer from the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1012,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(from != address(0), \"ERC777: send from the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1039,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(from != address(0), \"ERC777: burn from the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1072,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(spender != address(0), \"ERC777: approve to the zero address\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 1129,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(!to.isContract(), \"ERC777: token recipient contract has no implementer for ERC777TokensRecipient\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "erc777-reentrancy",
          "vulnerability_from_line": 1127,
          "vulnerability_to_line": null,
          "vulnerability_code": "            IERC777Recipient(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);\n",
          "message": "ERC777 tokensReceived() reentrancy"
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_41"
      ],
      "vulnerability_findings": [
        {
          "name": "constant-function",
          "vulnerability_from_line": 635,
          "vulnerability_to_line": 648,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n        \n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { codehash := extcodehash(account) }\n\n        return (codehash != 0x0 && codehash != accountHash);\n",
          "message": "Address.isContract (ERC777SenderRecipientMock.sol#635-648) is declared view but contains assembly code\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 321,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setInterfaceImplementer(address account, bytes32 interfaceHash, address implementer) external;\n",
          "message": "IERC1820Registry.setInterfaceImplementer.interfaceHash (local variable @ ERC777SenderRecipientMock.sol#321) shadows:\n\t- IERC1820Registry.interfaceHash (function @ ERC777SenderRecipientMock.sol#339)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 332,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getInterfaceImplementer(address account, bytes32 interfaceHash) external view returns (address);\n",
          "message": "IERC1820Registry.getInterfaceImplementer.interfaceHash (local variable @ ERC777SenderRecipientMock.sol#332) shadows:\n\t- IERC1820Registry.interfaceHash (function @ ERC777SenderRecipientMock.sol#339)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 725,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string memory name,\n",
          "message": "ERC777.constructor.name (local variable @ ERC777SenderRecipientMock.sol#725) shadows:\n\t- ERC777.name (function @ ERC777SenderRecipientMock.sol#745-747)\n\t- IERC777.name (function @ ERC777SenderRecipientMock.sol#18)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 726,
          "vulnerability_to_line": null,
          "vulnerability_code": "        string memory symbol,\n",
          "message": "ERC777.constructor.symbol (local variable @ ERC777SenderRecipientMock.sol#726) shadows:\n\t- ERC777.symbol (function @ ERC777SenderRecipientMock.sol#752-754)\n\t- IERC777.symbol (function @ ERC777SenderRecipientMock.sol#24)\n"
        },
        {
          "name": "shadowing-local",
          "vulnerability_from_line": 727,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] memory defaultOperators\n",
          "message": "ERC777.constructor.defaultOperators (local variable @ ERC777SenderRecipientMock.sol#727) shadows:\n\t- ERC777.defaultOperators (function @ ERC777SenderRecipientMock.sol#874-876)\n\t- IERC777.defaultOperators (function @ ERC777SenderRecipientMock.sol#121)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1030,
          "vulnerability_to_line": 1049,
          "vulnerability_code": "    function _burn(\n\n        address operator,\n\n        address from,\n\n        uint256 amount,\n\n        bytes memory data,\n\n        bytes memory operatorData\n\n    )\n\n        internal\n\n    {\n\n        require(from != address(0), \"ERC777: burn from the zero address\");\n\n\n\n        _callTokensToSend(operator, from, address(0), amount, data, operatorData);\n\n\n\n        // Update state variables\n\n        _totalSupply = _totalSupply.sub(amount);\n\n        _balances[from] = _balances[from].sub(amount);\n\n\n\n        emit Burned(operator, from, amount, data, operatorData);\n\n        emit Transfer(from, address(0), amount);\n",
          "message": "Reentrancy in ERC777._burn (ERC777SenderRecipientMock.sol#1030-1049):\n\tExternal calls:\n\t- _callTokensToSend(operator,from,address(0),amount,data,operatorData) (ERC777SenderRecipientMock.sol#1041)\n\tState variables written after the call(s):\n\t- _balances (ERC777SenderRecipientMock.sol#1045)\n\t- _totalSupply (ERC777SenderRecipientMock.sol#1044)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 1001,
          "vulnerability_to_line": 1020,
          "vulnerability_code": "    function _send(\n\n        address operator,\n\n        address from,\n\n        address to,\n\n        uint256 amount,\n\n        bytes memory userData,\n\n        bytes memory operatorData,\n\n        bool requireReceptionAck\n\n    )\n\n        private\n\n    {\n\n        require(from != address(0), \"ERC777: send from the zero address\");\n\n        require(to != address(0), \"ERC777: send to the zero address\");\n\n\n\n        _callTokensToSend(operator, from, to, amount, userData, operatorData);\n\n\n\n        _move(operator, from, to, amount, userData, operatorData);\n\n\n\n        _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);\n",
          "message": "Reentrancy in ERC777._send (ERC777SenderRecipientMock.sol#1001-1020):\n\tExternal calls:\n\t- _callTokensToSend(operator,from,to,amount,userData,operatorData) (ERC777SenderRecipientMock.sol#1015)\n\tState variables written after the call(s):\n\t- _balances (ERC777SenderRecipientMock.sol#1017)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 806,
          "vulnerability_to_line": 818,
          "vulnerability_code": "    function transfer(address recipient, uint256 amount) external returns (bool) {\n\n        require(recipient != address(0), \"ERC777: transfer to the zero address\");\n\n\n\n        address from = msg.sender;\n\n\n\n        _callTokensToSend(from, from, recipient, amount, \"\", \"\");\n\n\n\n        _move(from, from, recipient, amount, \"\", \"\");\n\n\n\n        _callTokensReceived(from, from, recipient, amount, \"\", \"\", false);\n\n\n\n        return true;\n",
          "message": "Reentrancy in ERC777.transfer (ERC777SenderRecipientMock.sol#806-818):\n\tExternal calls:\n\t- _callTokensToSend(from,from,recipient,amount,,) (ERC777SenderRecipientMock.sol#811)\n\tState variables written after the call(s):\n\t- _balances (ERC777SenderRecipientMock.sol#813)\n"
        },
        {
          "name": "reentrancy-benign",
          "vulnerability_from_line": 937,
          "vulnerability_to_line": 951,
          "vulnerability_code": "    function transferFrom(address holder, address recipient, uint256 amount) external returns (bool) {\n\n        require(recipient != address(0), \"ERC777: transfer to the zero address\");\n\n        require(holder != address(0), \"ERC777: transfer from the zero address\");\n\n\n\n        address spender = msg.sender;\n\n\n\n        _callTokensToSend(spender, holder, recipient, amount, \"\", \"\");\n\n\n\n        _move(spender, holder, recipient, amount, \"\", \"\");\n\n        _approve(holder, spender, _allowances[holder][spender].sub(amount));\n\n\n\n        _callTokensReceived(spender, holder, recipient, amount, \"\", \"\", false);\n\n\n\n        return true;\n",
          "message": "Reentrancy in ERC777.transferFrom (ERC777SenderRecipientMock.sol#937-951):\n\tExternal calls:\n\t- _callTokensToSend(spender,holder,recipient,amount,,) (ERC777SenderRecipientMock.sol#943)\n\tState variables written after the call(s):\n\t- _allowances (ERC777SenderRecipientMock.sol#946)\n\t- _balances (ERC777SenderRecipientMock.sol#945)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 635,
          "vulnerability_to_line": 648,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n\n        // This method relies in extcodesize, which returns 0 for contracts in\n\n        // construction, since the code is only stored at the end of the\n\n        // constructor execution.\n\n        \n\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n\n        // for accounts without code, i.e. `keccak256('')`\n\n        bytes32 codehash;\n\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n        // solhint-disable-next-line no-inline-assembly\n\n        assembly { codehash := extcodehash(account) }\n\n        return (codehash != 0x0 && codehash != accountHash);\n",
          "message": "Address.isContract uses assembly (ERC777SenderRecipientMock.sol#635-648)\n\t- ERC777SenderRecipientMock.sol#646\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 745,
          "vulnerability_to_line": 747,
          "vulnerability_code": "    function name() public view returns (string memory) {\n\n        return _name;\n",
          "message": "ERC777.name (ERC777SenderRecipientMock.sol#745-747) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 18,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function name() external view returns (string memory);\n",
          "message": "IERC777.name (ERC777SenderRecipientMock.sol#18) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 24,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function symbol() external view returns (string memory);\n",
          "message": "IERC777.symbol (ERC777SenderRecipientMock.sol#24) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 752,
          "vulnerability_to_line": 754,
          "vulnerability_code": "    function symbol() public view returns (string memory) {\n\n        return _symbol;\n",
          "message": "ERC777.symbol (ERC777SenderRecipientMock.sol#752-754) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 771,
          "vulnerability_to_line": 773,
          "vulnerability_code": "    function granularity() public view returns (uint256) {\n\n        return 1;\n",
          "message": "ERC777.granularity (ERC777SenderRecipientMock.sol#771-773) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 33,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function granularity() external view returns (uint256);\n",
          "message": "IERC777.granularity (ERC777SenderRecipientMock.sol#33) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 778,
          "vulnerability_to_line": 780,
          "vulnerability_code": "    function totalSupply() public view returns (uint256) {\n\n        return _totalSupply;\n",
          "message": "ERC777.totalSupply (ERC777SenderRecipientMock.sol#778-780) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 440,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function totalSupply() external view returns (uint256);\n",
          "message": "IERC20.totalSupply (ERC777SenderRecipientMock.sol#440) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 445,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function balanceOf(address account) external view returns (uint256);\n",
          "message": "IERC20.balanceOf (ERC777SenderRecipientMock.sol#445) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 785,
          "vulnerability_to_line": 787,
          "vulnerability_code": "    function balanceOf(address tokenHolder) public view returns (uint256) {\n\n        return _balances[tokenHolder];\n",
          "message": "ERC777.balanceOf (ERC777SenderRecipientMock.sol#785-787) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 121,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function defaultOperators() external view returns (address[] memory);\n",
          "message": "IERC777.defaultOperators (ERC777SenderRecipientMock.sol#121) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 874,
          "vulnerability_to_line": 876,
          "vulnerability_code": "    function defaultOperators() public view returns (address[] memory) {\n\n        return _defaultOperatorsArray;\n",
          "message": "ERC777.defaultOperators (ERC777SenderRecipientMock.sol#874-876) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 463,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function allowance(address owner, address spender) external view returns (uint256);\n",
          "message": "IERC20.allowance (ERC777SenderRecipientMock.sol#463) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 913,
          "vulnerability_to_line": 915,
          "vulnerability_code": "    function allowance(address holder, address spender) public view returns (uint256) {\n\n        return _allowances[holder][spender];\n",
          "message": "ERC777.allowance (ERC777SenderRecipientMock.sol#913-915) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 762,
          "vulnerability_to_line": 764,
          "vulnerability_code": "    function decimals() public pure returns (uint8) {\n\n        return 18;\n",
          "message": "ERC777.decimals (ERC777SenderRecipientMock.sol#762-764) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1237,
          "vulnerability_to_line": 1244,
          "vulnerability_code": "    function senderFor(address account) public {\n\n        _registerInterfaceForAddress(TOKENS_SENDER_INTERFACE_HASH, account);\n\n\n\n        address self = address(this);\n\n        if (account == self) {\n\n            registerSender(self);\n\n        }\n",
          "message": "ERC777SenderRecipientMock.senderFor (ERC777SenderRecipientMock.sol#1237-1244) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1250,
          "vulnerability_to_line": 1257,
          "vulnerability_code": "    function recipientFor(address account) public {\n\n        _registerInterfaceForAddress(TOKENS_RECIPIENT_INTERFACE_HASH, account);\n\n\n\n        address self = address(this);\n\n        if (account == self) {\n\n            registerRecipient(self);\n\n        }\n",
          "message": "ERC777SenderRecipientMock.recipientFor (ERC777SenderRecipientMock.sol#1250-1257) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1263,
          "vulnerability_to_line": 1265,
          "vulnerability_code": "    function setShouldRevertSend(bool shouldRevert) public {\n\n        _shouldRevertSend = shouldRevert;\n",
          "message": "ERC777SenderRecipientMock.setShouldRevertSend (ERC777SenderRecipientMock.sol#1263-1265) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1267,
          "vulnerability_to_line": 1269,
          "vulnerability_code": "    function setShouldRevertReceive(bool shouldRevert) public {\n\n        _shouldRevertReceive = shouldRevert;\n",
          "message": "ERC777SenderRecipientMock.setShouldRevertReceive (ERC777SenderRecipientMock.sol#1267-1269) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1271,
          "vulnerability_to_line": 1274,
          "vulnerability_code": "    function send(IERC777 token, address to, uint256 amount, bytes memory data) public {\n\n        // This is 777's send function, not the Solidity send function\n\n        token.send(to, amount, data); // solhint-disable-line check-send-result\n",
          "message": "ERC777SenderRecipientMock.send (ERC777SenderRecipientMock.sol#1271-1274) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 1276,
          "vulnerability_to_line": 1278,
          "vulnerability_code": "    function burn(IERC777 token, uint256 amount, bytes memory data) public {\n\n        token.burn(amount, data);\n",
          "message": "ERC777SenderRecipientMock.burn (ERC777SenderRecipientMock.sol#1276-1278) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": "Detected issues with version pragma in ERC777SenderRecipientMock.sol:\n\t- pragma solidity^0.5.0 (ERC777SenderRecipientMock.sol#3): it allows old versions\n\t- pragma solidity^0.5.0 (ERC777SenderRecipientMock.sol#192): it allows old versions\n\t- pragma solidity^0.5.0 (ERC777SenderRecipientMock.sol#227): it allows old versions\n\t- pragma solidity^0.5.0 (ERC777SenderRecipientMock.sol#262): it allows old versions\n\t- pragma solidity^0.5.0 (ERC777SenderRecipientMock.sol#374): it allows old versions\n\t- pragma solidity^0.5.0 (ERC777SenderRecipientMock.sol#394): it allows old versions\n\t- pragma solidity^0.5.0 (ERC777SenderRecipientMock.sol#430): it allows old versions\n\t- pragma solidity^0.5.0 (ERC777SenderRecipientMock.sol#509): it allows old versions\n\t- pragma solidity^0.5.0 (ERC777SenderRecipientMock.sol#619): it allows old versions\n\t- pragma solidity^0.5.0 (ERC777SenderRecipientMock.sol#661): it allows old versions\n\t- pragma solidity^0.5.0 (ERC777SenderRecipientMock.sol#1136): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 423,
          "vulnerability_to_line": 425,
          "vulnerability_code": "    function _registerInterfaceForAddress(bytes32 interfaceHash, address account) internal {\n\n        _supportedInterfaces[interfaceHash][account] = true;\n",
          "message": "Function 'ERC1820Implementer._registerInterfaceForAddress' (ERC777SenderRecipientMock.sol#423-425) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 970,
          "vulnerability_to_line": 989,
          "vulnerability_code": "    function _mint(\n\n        address operator,\n\n        address account,\n\n        uint256 amount,\n\n        bytes memory userData,\n\n        bytes memory operatorData\n\n    )\n\n    internal\n\n    {\n\n        require(account != address(0), \"ERC777: mint to the zero address\");\n\n\n\n        // Update state variables\n\n        _totalSupply = _totalSupply.add(amount);\n\n        _balances[account] = _balances[account].add(amount);\n\n\n\n        _callTokensReceived(operator, address(0), account, amount, userData, operatorData, true);\n\n\n\n        emit Minted(operator, account, amount, userData, operatorData);\n\n        emit Transfer(address(0), account, amount);\n",
          "message": "Function 'ERC777._mint' (ERC777SenderRecipientMock.sol#970-989) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1001,
          "vulnerability_to_line": 1020,
          "vulnerability_code": "    function _send(\n\n        address operator,\n\n        address from,\n\n        address to,\n\n        uint256 amount,\n\n        bytes memory userData,\n\n        bytes memory operatorData,\n\n        bool requireReceptionAck\n\n    )\n\n        private\n\n    {\n\n        require(from != address(0), \"ERC777: send from the zero address\");\n\n        require(to != address(0), \"ERC777: send to the zero address\");\n\n\n\n        _callTokensToSend(operator, from, to, amount, userData, operatorData);\n\n\n\n        _move(operator, from, to, amount, userData, operatorData);\n\n\n\n        _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);\n",
          "message": "Function 'ERC777._send' (ERC777SenderRecipientMock.sol#1001-1020) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1030,
          "vulnerability_to_line": 1049,
          "vulnerability_code": "    function _burn(\n\n        address operator,\n\n        address from,\n\n        uint256 amount,\n\n        bytes memory data,\n\n        bytes memory operatorData\n\n    )\n\n        internal\n\n    {\n\n        require(from != address(0), \"ERC777: burn from the zero address\");\n\n\n\n        _callTokensToSend(operator, from, address(0), amount, data, operatorData);\n\n\n\n        // Update state variables\n\n        _totalSupply = _totalSupply.sub(amount);\n\n        _balances[from] = _balances[from].sub(amount);\n\n\n\n        emit Burned(operator, from, amount, data, operatorData);\n\n        emit Transfer(from, address(0), amount);\n",
          "message": "Function 'ERC777._burn' (ERC777SenderRecipientMock.sol#1030-1049) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1051,
          "vulnerability_to_line": 1066,
          "vulnerability_code": "    function _move(\n\n        address operator,\n\n        address from,\n\n        address to,\n\n        uint256 amount,\n\n        bytes memory userData,\n\n        bytes memory operatorData\n\n    )\n\n        internal\n\n    {\n\n        _balances[from] = _balances[from].sub(amount);\n\n        _balances[to] = _balances[to].add(amount);\n\n\n\n        emit Sent(operator, from, to, amount, userData, operatorData);\n\n        emit Transfer(from, to, amount);\n",
          "message": "Function 'ERC777._move' (ERC777SenderRecipientMock.sol#1051-1066) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1068,
          "vulnerability_to_line": 1076,
          "vulnerability_code": "    function _approve(address holder, address spender, uint256 value) private {\n\n        // TODO: restore this require statement if this function becomes internal, or is called at a new callsite. It is\n\n        // currently unnecessary.\n\n        //require(holder != address(0), \"ERC777: approve from the zero address\");\n\n        require(spender != address(0), \"ERC777: approve to the zero address\");\n\n\n\n        _allowances[holder][spender] = value;\n\n        emit Approval(holder, spender, value);\n",
          "message": "Function 'ERC777._approve' (ERC777SenderRecipientMock.sol#1068-1076) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1087,
          "vulnerability_to_line": 1101,
          "vulnerability_code": "    function _callTokensToSend(\n\n        address operator,\n\n        address from,\n\n        address to,\n\n        uint256 amount,\n\n        bytes memory userData,\n\n        bytes memory operatorData\n\n    )\n\n        private\n\n    {\n\n        address implementer = _erc1820.getInterfaceImplementer(from, TOKENS_SENDER_INTERFACE_HASH);\n\n        if (implementer != address(0)) {\n\n            IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);\n\n        }\n",
          "message": "Function 'ERC777._callTokensToSend' (ERC777SenderRecipientMock.sol#1087-1101) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 1114,
          "vulnerability_to_line": 1131,
          "vulnerability_code": "    function _callTokensReceived(\n\n        address operator,\n\n        address from,\n\n        address to,\n\n        uint256 amount,\n\n        bytes memory userData,\n\n        bytes memory operatorData,\n\n        bool requireReceptionAck\n\n    )\n\n        private\n\n    {\n\n        address implementer = _erc1820.getInterfaceImplementer(to, TOKENS_RECIPIENT_INTERFACE_HASH);\n\n        if (implementer != address(0)) {\n\n            IERC777Recipient(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);\n\n        } else if (requireReceptionAck) {\n\n            require(!to.isContract(), \"ERC777: token recipient contract has no implementer for ERC777TokensRecipient\");\n\n        }\n",
          "message": "Function 'ERC777._callTokensReceived' (ERC777SenderRecipientMock.sol#1114-1131) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 688,
          "vulnerability_to_line": null,
          "vulnerability_code": "    IERC1820Registry private _erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 1170,
          "vulnerability_to_line": null,
          "vulnerability_code": "    IERC1820Registry private _erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 413,
          "vulnerability_to_line": null,
          "vulnerability_code": "        return _supportedInterfaces[interfaceHash][account] ? ERC1820_ACCEPT_MAGIC : bytes32(0x00);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 733,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _defaultOperatorsArray.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 733,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _defaultOperatorsArray.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 192,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 227,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 262,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 374,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 394,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 430,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 509,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 619,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 661,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 1136,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 405,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 constant private ERC1820_ACCEPT_MAGIC = keccak256(abi.encodePacked(\"ERC1820_ACCEPT_MAGIC\"));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 407,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(bytes32 => mapping(address => bool)) private _supportedInterfaces;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 688,
          "vulnerability_to_line": null,
          "vulnerability_code": "    IERC1820Registry private _erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 690,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => uint256) private _balances;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 692,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 private _totalSupply;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 694,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string private _name;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 695,
          "vulnerability_to_line": null,
          "vulnerability_code": "    string private _symbol;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 701,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 constant private TOKENS_SENDER_INTERFACE_HASH =\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 705,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 constant private TOKENS_RECIPIENT_INTERFACE_HASH =\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 709,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address[] private _defaultOperatorsArray;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 712,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => bool) private _defaultOperators;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 715,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => mapping(address => bool)) private _operators;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 716,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(address => mapping(address => bool)) private _revokedDefaultOperators;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 719,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping (address => mapping (address => uint256)) private _allowances;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 1167,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool private _shouldRevertSend;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 1168,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bool private _shouldRevertReceive;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 1170,
          "vulnerability_to_line": null,
          "vulnerability_code": "    IERC1820Registry private _erc1820 = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 1172,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 constant private TOKENS_SENDER_INTERFACE_HASH = keccak256(\"ERC777TokensSender\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 1173,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes32 constant private TOKENS_RECIPIENT_INTERFACE_HASH = keccak256(\"ERC777TokensRecipient\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 685,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_VIEW",
          "vulnerability_from_line": 635,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isContract(address account) internal view returns (bool) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 795,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _send(msg.sender, msg.sender, recipient, amount, data, \"\", true);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 811,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _callTokensToSend(from, from, recipient, amount, \"\", \"\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_UNCHECKED_CALL",
          "vulnerability_from_line": 815,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _callTokensReceived(from, from, recipient, amount, \"\", \"\", false);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 646,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly { codehash := extcodehash(account) }\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 142,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function operatorSend(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 165,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function operatorBurn(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 215,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function tokensToSend(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 250,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function tokensReceived(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 883,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function operatorSend(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1175,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function tokensToSend(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 146,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes calldata data,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 147,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes calldata operatorData\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 168,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes calldata data,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 169,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes calldata operatorData\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 220,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes calldata userData,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 221,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes calldata operatorData\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 255,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes calldata userData,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 256,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes calldata operatorData\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 887,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes calldata data,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 888,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes calldata operatorData\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 892,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(isOperatorFor(msg.sender, sender), \"ERC777: caller is not an operator for holder\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 892,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(isOperatorFor(msg.sender, sender), \"ERC777: caller is not an operator for holder\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 893,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _send(msg.sender, sender, recipient, amount, data, operatorData, true);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 893,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _send(msg.sender, sender, recipient, amount, data, operatorData, true);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 893,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _send(msg.sender, sender, recipient, amount, data, operatorData, true);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 893,
          "vulnerability_to_line": null,
          "vulnerability_code": "        _send(msg.sender, sender, recipient, amount, data, operatorData, true);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1180,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes calldata userData,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1181,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes calldata operatorData\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1183,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (_shouldRevertSend) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 1184,
          "vulnerability_to_line": null,
          "vulnerability_code": "            revert();\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (IndexError: pop from empty list)"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 1222,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 toBalance = token.balanceOf(to);\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 1273,
          "vulnerability_to_line": null,
          "vulnerability_code": "        token.send(to, amount, data); // solhint-disable-line check-send-result\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "External Call To User-Supplied Address (SWC 107)",
          "vulnerability_from_line": 1277,
          "vulnerability_to_line": null,
          "vulnerability_code": "        token.burn(amount, data);\n",
          "message": "A call to a user-supplied address is executed.\nAn external message call to an address specified by the caller is executed. Note that the callee account might contain arbitrary code and could re-enter any function within this contract. Reentering the contract in an intermediate state may lead to unexpected behaviour. Make sure that no state modifications are executed after this call and/or reentrancy guards are in place.\nClassification: SWC-107"
        },
        {
          "name": "Multiple Calls in a Single Transaction (SWC 113)",
          "vulnerability_from_line": 1191,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 toBalance = token.balanceOf(to);\n",
          "message": "Multiple calls are executed in the same transaction.\nThis call is executed following another call within the same transaction. It is possible that the call never gets executed if a prior call fails permanently. This might be caused intentionally by a malicious callee. If possible, refactor the code such that each transaction only executes one external call or make sure that all callees can be trusted (i.e. they\u2019re part of your own codebase).\nClassification: SWC-113"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}