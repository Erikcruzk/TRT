{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 255,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; i++) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 709,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require(uint256(s).add(32) <= signatures.length, \"Invalid contract signature location: length not present\");\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 717,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require(uint256(s).add(32).add(contractSignatureLen) <= signatures.length, \"Invalid contract signature location: data not complete\");\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 211,
          "vulnerability_to_line": null,
          "vulnerability_code": "            currentModule = modules[currentModule];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 221,
          "vulnerability_to_line": null,
          "vulnerability_code": "            currentModule = modules[currentModule];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 260,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(owners[owner] == address(0), \"Duplicate owner address provided\");\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 261,
          "vulnerability_to_line": null,
          "vulnerability_code": "            owners[currentOwner] = owner;\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 381,
          "vulnerability_to_line": null,
          "vulnerability_code": "            currentOwner = owners[currentOwner];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 733,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require(msg.sender == currentOwner || approvedHashes[currentOwner][dataHash] != 0, \"Hash has not been approved\");\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 736,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    approvedHashes[currentOwner][dataHash] = 0;\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "unnecessary-checked-arithmetic-in-loop",
          "vulnerability_from_line": 255,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; i++) {\n",
          "message": "A lot of times there is no risk that the loop counter can overflow. Using Solidity's unchecked block saves the overflow checks."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 79,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == address(this), \"Method can only be called from this contract\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 146,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(modules[SENTINEL_MODULES] == address(0), \"Modules have already been initialized\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 150,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(executeDelegateCall(to, data, gasleft()), \"Could not finish initialization\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 161,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 163,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(modules[address(module)] == address(0), \"Module has already been added\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 178,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 179,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(modules[address(prevModule)] == address(module), \"Invalid prevModule, module pair provided\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 195,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"Method can only be called from an enabled module\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 248,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(threshold == 0, \"Owners have already been setup\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 250,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_threshold <= _owners.length, \"Threshold cannot exceed owner count\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 252,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 258,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 260,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(owners[owner] == address(0), \"Duplicate owner address provided\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 278,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 280,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(owners[owner] == address(0), \"Address is already an owner\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 300,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(ownerCount - 1 >= _threshold, \"New owner count needs to be larger than new threshold\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 302,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 303,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(owners[prevOwner] == owner, \"Invalid prevOwner, owner pair provided\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 323,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 325,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(owners[newOwner] == address(0), \"Address is already an owner\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 327,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 328,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(owners[prevOwner] == oldOwner, \"Invalid prevOwner, owner pair provided\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 344,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_threshold <= ownerCount, \"Threshold cannot exceed owner count\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 346,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 403,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_masterCopy != address(0), \"Invalid master copy address provided\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 414,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == address(manager), \"Method can only be called from manager\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 423,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(manager) == address(0), \"Manager has already been set\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 595,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(domainSeparator == 0, \"Domain Separator already set!\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 644,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(gasleft() >= safeTxGas, \"Not enough gas to execute safe transaction\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 673,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(receiver.send(gasUsed.add(baseGas).mul(gasPrice < tx.gasprice ? gasPrice : tx.gasprice)), \"Could not pay gas costs with ether\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 675,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(transferToken(gasToken, receiver, gasUsed.add(baseGas).mul(gasPrice)), \"Could not pay gas costs with token\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 689,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(signatures.length >= threshold.mul(65), \"Signatures data too short\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 706,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require(uint256(s) >= threshold.mul(65), \"Invalid contract signature location: inside static part\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 709,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require(uint256(s).add(32) <= signatures.length, \"Invalid contract signature location: length not present\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 717,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require(uint256(s).add(32).add(contractSignatureLen) <= signatures.length, \"Invalid contract signature location: data not complete\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 726,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require(ISignatureValidator(currentOwner).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"Invalid contract signature provided\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 733,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require(msg.sender == currentOwner || approvedHashes[currentOwner][dataHash] != 0, \"Hash has not been approved\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 747,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require (\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 748,
          "vulnerability_to_line": null,
          "vulnerability_code": "                currentOwner > lastOwner && owners[currentOwner] != address(0) && currentOwner != SENTINEL_OWNERS,\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 749,
          "vulnerability_to_line": null,
          "vulnerability_code": "                \"Invalid owner provided\"\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 750,
          "vulnerability_to_line": null,
          "vulnerability_code": "            );\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 787,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(owners[msg.sender] != address(0), \"Only owners can approve a hash\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-custom-error-not-require",
          "vulnerability_from_line": 817,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(signedMessages[messageHash] != 0, \"Hash not approved\");\n",
          "message": "Consider using custom errors as they are more gas efficient while allowing developers  to describe the error in detail using NatSpec."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 161,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 178,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 195,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"Method can only be called from an enabled module\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 258,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 278,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 302,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 323,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 327,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 747,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require (\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 748,
          "vulnerability_to_line": null,
          "vulnerability_code": "                currentOwner > lastOwner && owners[currentOwner] != address(0) && currentOwner != SENTINEL_OWNERS,\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 749,
          "vulnerability_to_line": null,
          "vulnerability_code": "                \"Invalid owner provided\"\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-multiple-require",
          "vulnerability_from_line": 750,
          "vulnerability_to_line": null,
          "vulnerability_code": "            );\n",
          "message": "Using multiple require statements is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 735,
          "vulnerability_to_line": null,
          "vulnerability_code": "                if (consumeHash && msg.sender != currentOwner) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 736,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    approvedHashes[currentOwner][dataHash] = 0;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 737,
          "vulnerability_to_line": null,
          "vulnerability_code": "                }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": null,
          "vulnerability_code": "        ownerCount--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 212,
          "vulnerability_to_line": null,
          "vulnerability_code": "            moduleCount ++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 222,
          "vulnerability_to_line": null,
          "vulnerability_code": "            moduleCount ++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 255,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 283,
          "vulnerability_to_line": null,
          "vulnerability_code": "        ownerCount++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 382,
          "vulnerability_to_line": null,
          "vulnerability_code": "            index ++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 642,
          "vulnerability_to_line": null,
          "vulnerability_code": "        nonce++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 697,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (i = 0; i < threshold; i++) {\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 79,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == address(this), \"Method can only be called from this contract\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 146,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(modules[SENTINEL_MODULES] == address(0), \"Modules have already been initialized\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 179,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(modules[address(prevModule)] == address(module), \"Invalid prevModule, module pair provided\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 195,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"Method can only be called from an enabled module\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 250,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_threshold <= _owners.length, \"Threshold cannot exceed owner count\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 252,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 300,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(ownerCount - 1 >= _threshold, \"New owner count needs to be larger than new threshold\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 303,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(owners[prevOwner] == owner, \"Invalid prevOwner, owner pair provided\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 328,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(owners[prevOwner] == oldOwner, \"Invalid prevOwner, owner pair provided\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 344,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_threshold <= ownerCount, \"Threshold cannot exceed owner count\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 346,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 403,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(_masterCopy != address(0), \"Invalid master copy address provided\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 414,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(msg.sender == address(manager), \"Method can only be called from manager\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 644,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(gasleft() >= safeTxGas, \"Not enough gas to execute safe transaction\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 673,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(receiver.send(gasUsed.add(baseGas).mul(gasPrice < tx.gasprice ? gasPrice : tx.gasprice)), \"Could not pay gas costs with ether\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 675,
          "vulnerability_to_line": null,
          "vulnerability_code": "            require(transferToken(gasToken, receiver, gasUsed.add(baseGas).mul(gasPrice)), \"Could not pay gas costs with token\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 706,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require(uint256(s) >= threshold.mul(65), \"Invalid contract signature location: inside static part\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 709,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require(uint256(s).add(32) <= signatures.length, \"Invalid contract signature location: length not present\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 717,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require(uint256(s).add(32).add(contractSignatureLen) <= signatures.length, \"Invalid contract signature location: data not complete\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        },
        {
          "name": "use-short-revert-string",
          "vulnerability_from_line": 726,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require(ISignatureValidator(currentOwner).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"Invalid contract signature provided\");\n",
          "message": "Shortening revert strings to fit in 32 bytes will decrease gas costs for deployment and  gas costs when the revert condition has been met."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_38"
      ],
      "vulnerability_findings": [
        {
          "name": "arbitrary-send",
          "vulnerability_from_line": 659,
          "vulnerability_to_line": 677,
          "vulnerability_code": "    function handlePayment(\n\n        uint256 gasUsed,\n\n        uint256 baseGas,\n\n        uint256 gasPrice,\n\n        address gasToken,\n\n        address payable refundReceiver\n\n    )\n\n        private\n\n    {\n\n        // solium-disable-next-line security/no-tx-origin\n\n        address payable receiver = refundReceiver == address(0) ? tx.origin : refundReceiver;\n\n        if (gasToken == address(0)) {\n\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\n\n            // solium-disable-next-line security/no-send\n\n            require(receiver.send(gasUsed.add(baseGas).mul(gasPrice < tx.gasprice ? gasPrice : tx.gasprice)), \"Could not pay gas costs with ether\");\n\n        } else {\n\n            require(transferToken(gasToken, receiver, gasUsed.add(baseGas).mul(gasPrice)), \"Could not pay gas costs with token\");\n\n        }\n",
          "message": "GnosisSafe.handlePayment (GnosisSafe.sol#659-677) sends eth to arbitrary user\n\tDangerous calls:\n\t- require(bool,string)(receiver.send(gasUsed.add(baseGas).mul(gasPrice)),Could not pay gas costs with ether) (GnosisSafe.sol#673)\n\t- require(bool,string)(receiver.send(gasUsed.add(baseGas).mul(tx.gasprice)),Could not pay gas costs with ether) (GnosisSafe.sol#673)\n"
        },
        {
          "name": "constant-function",
          "vulnerability_from_line": 454,
          "vulnerability_to_line": 474,
          "vulnerability_code": "    function signatureSplit(bytes memory signatures, uint256 pos)\n\n        internal\n\n        pure\n\n        returns (uint8 v, bytes32 r, bytes32 s)\n\n    {\n\n        // The signature format is a compact form of:\n\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n\n        // Compact means, uint8 is not padded to 32 bytes.\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            let signaturePos := mul(0x41, pos)\n\n            r := mload(add(signatures, add(signaturePos, 0x20)))\n\n            s := mload(add(signatures, add(signaturePos, 0x40)))\n\n            // Here we are loading the last 32 bytes, including 31 bytes\n\n            // of 's'. There is no 'mload8' to do this.\n\n            //\n\n            // 'byte' is not working due to the Solidity parser, so lets\n\n            // use the second best option, 'and'\n\n            v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)\n\n        }\n",
          "message": "SignatureDecoder.signatureSplit (GnosisSafe.sol#454-474) is declared view but contains assembly code\n"
        },
        {
          "name": "calls-loop",
          "vulnerability_from_line": 726,
          "vulnerability_to_line": null,
          "vulnerability_code": "                require(ISignatureValidator(currentOwner).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"Invalid contract signature provided\");\n",
          "message": "GnosisSafe.checkSignatures has external calls inside a loop:\n\t- require(bool,string)(ISignatureValidator(currentOwner).isValidSignature(data,contractSignature) == EIP1271_MAGIC_VALUE,Invalid contract signature provided) (GnosisSafe.sol#726)\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 21,
          "vulnerability_to_line": 29,
          "vulnerability_code": "    function executeCall(address to, uint256 value, bytes memory data, uint256 txGas)\n\n        internal\n\n        returns (bool success)\n\n    {\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\n\n        }\n",
          "message": "Executor.executeCall uses assembly (GnosisSafe.sol#21-29)\n\t- GnosisSafe.sol#26-28\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": 39,
          "vulnerability_code": "    function executeDelegateCall(address to, bytes memory data, uint256 txGas)\n\n        internal\n\n        returns (bool success)\n\n    {\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\n\n        }\n",
          "message": "Executor.executeDelegateCall uses assembly (GnosisSafe.sol#31-39)\n\t- GnosisSafe.sol#36-38\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": 74,
          "vulnerability_code": "    function transferToken (\n\n        address token,\n\n        address receiver,\n\n        uint256 amount\n\n    )\n\n        internal\n\n        returns (bool transferred)\n\n    {\n\n        bytes memory data = abi.encodeWithSignature(\"transfer(address,uint256)\", receiver, amount);\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            let success := call(sub(gas, 10000), token, 0, add(data, 0x20), mload(data), 0, 0)\n\n            let ptr := mload(0x40)\n\n            returndatacopy(ptr, 0, returndatasize)\n\n            switch returndatasize\n\n            case 0 { transferred := success }\n\n            case 0x20 { transferred := iszero(or(iszero(success), iszero(mload(ptr)))) }\n\n            default { transferred := 0 }\n\n        }\n",
          "message": "SecuredTokenTransfer.transferToken uses assembly (GnosisSafe.sol#55-74)\n\t- GnosisSafe.sol#65-73\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 89,
          "vulnerability_to_line": 95,
          "vulnerability_code": "    function internalSetFallbackHandler(address handler) internal {\n\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            sstore(slot, handler)\n\n        }\n",
          "message": "FallbackManager.internalSetFallbackHandler uses assembly (GnosisSafe.sol#89-95)\n\t- GnosisSafe.sol#92-94\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 108,
          "vulnerability_to_line": 131,
          "vulnerability_code": "    function ()\n\n        external\n\n        payable\n\n    {\n\n        // Only calls without value and with data will be forwarded\n\n        if (msg.value > 0 || msg.data.length == 0) return;\n\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\n\n        address handler;\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            handler := sload(slot)\n\n        }\n\n\n\n        if (handler != address(0)) {\n\n            // solium-disable-next-line security/no-inline-assembly\n\n            assembly {\n\n                calldatacopy(0, 0, calldatasize())\n\n                let success := call(gas, handler, 0, 0, calldatasize(), 0, 0)\n\n                returndatacopy(0, 0, returndatasize())\n\n                if eq(success, 0) { revert(0, returndatasize()) }\n\n                return(0, returndatasize())\n\n            }\n\n        }\n",
          "message": "FallbackManager.fallback uses assembly (GnosisSafe.sol#108-131)\n\t- GnosisSafe.sol#117-119\n\t- GnosisSafe.sol#123-129\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 454,
          "vulnerability_to_line": 474,
          "vulnerability_code": "    function signatureSplit(bytes memory signatures, uint256 pos)\n\n        internal\n\n        pure\n\n        returns (uint8 v, bytes32 r, bytes32 s)\n\n    {\n\n        // The signature format is a compact form of:\n\n        //   {bytes32 r}{bytes32 s}{uint8 v}\n\n        // Compact means, uint8 is not padded to 32 bytes.\n\n        // solium-disable-next-line security/no-inline-assembly\n\n        assembly {\n\n            let signaturePos := mul(0x41, pos)\n\n            r := mload(add(signatures, add(signaturePos, 0x20)))\n\n            s := mload(add(signatures, add(signaturePos, 0x40)))\n\n            // Here we are loading the last 32 bytes, including 31 bytes\n\n            // of 's'. There is no 'mload8' to do this.\n\n            //\n\n            // 'byte' is not working due to the Solidity parser, so lets\n\n            // use the second best option, 'and'\n\n            v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)\n\n        }\n",
          "message": "SignatureDecoder.signatureSplit uses assembly (GnosisSafe.sol#454-474)\n\t- GnosisSafe.sol#463-473\n"
        },
        {
          "name": "assembly",
          "vulnerability_from_line": 685,
          "vulnerability_to_line": 753,
          "vulnerability_code": "    function checkSignatures(bytes32 dataHash, bytes memory data, bytes memory signatures, bool consumeHash)\n\n        internal\n\n    {\n\n        // Check that the provided signature data is not too short\n\n        require(signatures.length >= threshold.mul(65), \"Signatures data too short\");\n\n        // There cannot be an owner with address 0.\n\n        address lastOwner = address(0);\n\n        address currentOwner;\n\n        uint8 v;\n\n        bytes32 r;\n\n        bytes32 s;\n\n        uint256 i;\n\n        for (i = 0; i < threshold; i++) {\n\n            (v, r, s) = signatureSplit(signatures, i);\n\n            // If v is 0 then it is a contract signature\n\n            if (v == 0) {\n\n                // When handling contract signatures the address of the contract is encoded into r\n\n                currentOwner = address(uint256(r));\n\n                // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\n\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\n\n                // Here we only check that the pointer is not pointing inside the part that is being processed\n\n                require(uint256(s) >= threshold.mul(65), \"Invalid contract signature location: inside static part\");\n\n\n\n                // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\n\n                require(uint256(s).add(32) <= signatures.length, \"Invalid contract signature location: length not present\");\n\n\n\n                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\n\n                uint256 contractSignatureLen;\n\n                // solium-disable-next-line security/no-inline-assembly\n\n                assembly {\n\n                    contractSignatureLen := mload(add(add(signatures, s), 0x20))\n\n                }\n\n                require(uint256(s).add(32).add(contractSignatureLen) <= signatures.length, \"Invalid contract signature location: data not complete\");\n\n\n\n                // Check signature\n\n                bytes memory contractSignature;\n\n                // solium-disable-next-line security/no-inline-assembly\n\n                assembly {\n\n                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\n\n                    contractSignature := add(add(signatures, s), 0x20)\n\n                }\n\n                require(ISignatureValidator(currentOwner).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \"Invalid contract signature provided\");\n\n            // If v is 1 then it is an approved hash\n\n            } else if (v == 1) {\n\n                // When handling approved hashes the address of the approver is encoded into r\n\n                currentOwner = address(uint256(r));\n\n\n\n                // Hashes are automatically approved by the sender of the message or when they have been pre-approved via a separate transaction\n\n                require(msg.sender == currentOwner || approvedHashes[currentOwner][dataHash] != 0, \"Hash has not been approved\");\n\n                // Hash has been marked for consumption. If this hash was pre-approved free storage\n\n                if (consumeHash && msg.sender != currentOwner) {\n\n                    approvedHashes[currentOwner][dataHash] = 0;\n\n                }\n\n            } else if (v > 30) {\n\n                // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\n\n                currentOwner = ecrecover(keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", dataHash)), v - 4, r, s);\n\n \n\n\n\n            } else {\n\n                // Use ecrecover with the messageHash for EOA signatures\n\n                currentOwner = ecrecover(dataHash, v, r, s);\n\n            }\n\n            require (\n\n                currentOwner > lastOwner && owners[currentOwner] != address(0) && currentOwner != SENTINEL_OWNERS,\n\n                \"Invalid owner provided\"\n\n            );\n\n            lastOwner = currentOwner;\n\n        }\n",
          "message": "GnosisSafe.checkSignatures uses assembly (GnosisSafe.sol#685-753)\n\t- GnosisSafe.sol#714-716\n\t- GnosisSafe.sol#722-725\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 101,
          "vulnerability_to_line": 106,
          "vulnerability_code": "    function setFallbackHandler(address handler)\n\n        public\n\n        authorized\n\n    {\n\n        internalSetFallbackHandler(handler);\n",
          "message": "FallbackManager.setFallbackHandler (GnosisSafe.sol#101-106) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 156,
          "vulnerability_to_line": 167,
          "vulnerability_code": "    function enableModule(Module module)\n\n        public\n\n        authorized\n\n    {\n\n        // Module address cannot be null or sentinel.\n\n        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\n\n        // Module cannot be added twice.\n\n        require(modules[address(module)] == address(0), \"Module has already been added\");\n\n        modules[address(module)] = modules[SENTINEL_MODULES];\n\n        modules[SENTINEL_MODULES] = address(module);\n\n        emit EnabledModule(module);\n",
          "message": "ModuleManager.enableModule (GnosisSafe.sol#156-167) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 173,
          "vulnerability_to_line": 183,
          "vulnerability_code": "    function disableModule(Module prevModule, Module module)\n\n        public\n\n        authorized\n\n    {\n\n        // Validate module address and check that it corresponds to module index.\n\n        require(address(module) != address(0) && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\n\n        require(modules[address(prevModule)] == address(module), \"Invalid prevModule, module pair provided\");\n\n        modules[address(prevModule)] = modules[address(module)];\n\n        modules[address(module)] = address(0);\n\n        emit DisabledModule(module);\n",
          "message": "ModuleManager.disableModule (GnosisSafe.sol#173-183) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 190,
          "vulnerability_to_line": 198,
          "vulnerability_code": "    function execTransactionFromModule(address to, uint256 value, bytes memory data, Enum.Operation operation)\n\n        public\n\n        returns (bool success)\n\n    {\n\n        // Only whitelisted modules are allowed.\n\n        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \"Method can only be called from an enabled module\");\n\n        // Execute transaction without further confirmations.\n\n        success = execute(to, value, data, operation, gasleft());\n",
          "message": "ModuleManager.execTransactionFromModule (GnosisSafe.sol#190-198) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 202,
          "vulnerability_to_line": 225,
          "vulnerability_code": "    function getModules()\n\n        public\n\n        view\n\n        returns (address[] memory)\n\n    {\n\n        // Calculate module count\n\n        uint256 moduleCount = 0;\n\n        address currentModule = modules[SENTINEL_MODULES];\n\n        while(currentModule != SENTINEL_MODULES) {\n\n            currentModule = modules[currentModule];\n\n            moduleCount ++;\n\n        }\n\n        address[] memory array = new address[](moduleCount);\n\n\n\n        // populate return array\n\n        moduleCount = 0;\n\n        currentModule = modules[SENTINEL_MODULES];\n\n        while(currentModule != SENTINEL_MODULES) {\n\n            array[moduleCount] = currentModule;\n\n            currentModule = modules[currentModule];\n\n            moduleCount ++;\n\n        }\n\n        return array;\n",
          "message": "ModuleManager.getModules (GnosisSafe.sol#202-225) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 273,
          "vulnerability_to_line": 288,
          "vulnerability_code": "    function addOwnerWithThreshold(address owner, uint256 _threshold)\n\n        public\n\n        authorized\n\n    {\n\n        // Owner address cannot be null.\n\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n\n        // No duplicate owners allowed.\n\n        require(owners[owner] == address(0), \"Address is already an owner\");\n\n        owners[owner] = owners[SENTINEL_OWNERS];\n\n        owners[SENTINEL_OWNERS] = owner;\n\n        ownerCount++;\n\n        emit AddedOwner(owner);\n\n        // Change threshold if threshold was changed.\n\n        if (threshold != _threshold)\n\n            changeThreshold(_threshold);\n",
          "message": "OwnerManager.addOwnerWithThreshold (GnosisSafe.sol#273-288) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 295,
          "vulnerability_to_line": 311,
          "vulnerability_code": "    function removeOwner(address prevOwner, address owner, uint256 _threshold)\n\n        public\n\n        authorized\n\n    {\n\n        // Only allow to remove an owner, if threshold can still be reached.\n\n        require(ownerCount - 1 >= _threshold, \"New owner count needs to be larger than new threshold\");\n\n        // Validate owner address and check that it corresponds to owner index.\n\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n\n        require(owners[prevOwner] == owner, \"Invalid prevOwner, owner pair provided\");\n\n        owners[prevOwner] = owners[owner];\n\n        owners[owner] = address(0);\n\n        ownerCount--;\n\n        emit RemovedOwner(owner);\n\n        // Change threshold if threshold was changed.\n\n        if (threshold != _threshold)\n\n            changeThreshold(_threshold);\n",
          "message": "OwnerManager.removeOwner (GnosisSafe.sol#295-311) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 318,
          "vulnerability_to_line": 334,
          "vulnerability_code": "    function swapOwner(address prevOwner, address oldOwner, address newOwner)\n\n        public\n\n        authorized\n\n    {\n\n        // Owner address cannot be null.\n\n        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n\n        // No duplicate owners allowed.\n\n        require(owners[newOwner] == address(0), \"Address is already an owner\");\n\n        // Validate oldOwner address and check that it corresponds to owner index.\n\n        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n\n        require(owners[prevOwner] == oldOwner, \"Invalid prevOwner, owner pair provided\");\n\n        owners[newOwner] = owners[oldOwner];\n\n        owners[prevOwner] = newOwner;\n\n        owners[oldOwner] = address(0);\n\n        emit RemovedOwner(oldOwner);\n\n        emit AddedOwner(newOwner);\n",
          "message": "OwnerManager.swapOwner (GnosisSafe.sol#318-334) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 351,
          "vulnerability_to_line": 357,
          "vulnerability_code": "    function getThreshold()\n\n        public\n\n        view\n\n        returns (uint256)\n\n    {\n\n        return threshold;\n",
          "message": "OwnerManager.getThreshold (GnosisSafe.sol#351-357) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 359,
          "vulnerability_to_line": 365,
          "vulnerability_code": "    function isOwner(address owner)\n\n        public\n\n        view\n\n        returns (bool)\n\n    {\n\n        return owner != SENTINEL_OWNERS && owners[owner] != address(0);\n",
          "message": "OwnerManager.isOwner (GnosisSafe.sol#359-365) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 369,
          "vulnerability_to_line": 385,
          "vulnerability_code": "    function getOwners()\n\n        public\n\n        view\n\n        returns (address[] memory)\n\n    {\n\n        address[] memory array = new address[](ownerCount);\n\n\n\n        // populate return array\n\n        uint256 index = 0;\n\n        address currentOwner = owners[SENTINEL_OWNERS];\n\n        while(currentOwner != SENTINEL_OWNERS) {\n\n            array[index] = currentOwner;\n\n            currentOwner = owners[currentOwner];\n\n            index ++;\n\n        }\n\n        return array;\n",
          "message": "OwnerManager.getOwners (GnosisSafe.sol#369-385) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 398,
          "vulnerability_to_line": 406,
          "vulnerability_code": "    function changeMasterCopy(address _masterCopy)\n\n        public\n\n        authorized\n\n    {\n\n        // Master copy address cannot be null.\n\n        require(_masterCopy != address(0), \"Invalid master copy address provided\");\n\n        masterCopy = _masterCopy;\n\n        emit ChangedMasterCopy(_masterCopy);\n",
          "message": "MasterCopy.changeMasterCopy (GnosisSafe.sol#398-406) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 889,
          "vulnerability_to_line": 906,
          "vulnerability_code": "    function getTransactionHash(\n\n        address to,\n\n        uint256 value,\n\n        bytes memory data,\n\n        Enum.Operation operation,\n\n        uint256 safeTxGas,\n\n        uint256 baseGas,\n\n        uint256 gasPrice,\n\n        address gasToken,\n\n        address refundReceiver,\n\n        uint256 _nonce\n\n    )\n\n        public\n\n        view\n\n        returns (bytes32)\n\n    {\n\n        return keccak256(encodeTransactionData(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce));\n",
          "message": "GnosisSafe.getTransactionHash (GnosisSafe.sol#889-906) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 920,
          "vulnerability_to_line": 925,
          "vulnerability_code": "    function isValidSignature(\n\n        bytes memory _data,\n\n        bytes memory _signature)\n\n        public\n\n        view\n",
          "message": "ISignatureValidator.isValidSignature (GnosisSafe.sol#920-925) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.10;\n",
          "message": "Detected issues with version pragma in GnosisSafe.sol:\n\t- pragma solidity^0.5.10 (GnosisSafe.sol#3): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 243,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setupOwners(address[] memory _owners, uint256 _threshold)\n",
          "message": "Parameter '_owners' of OwnerManager.setupOwners (GnosisSafe.sol#243) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 243,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setupOwners(address[] memory _owners, uint256 _threshold)\n",
          "message": "Parameter '_threshold' of OwnerManager.setupOwners (GnosisSafe.sol#243) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 273,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function addOwnerWithThreshold(address owner, uint256 _threshold)\n",
          "message": "Parameter '_threshold' of OwnerManager.addOwnerWithThreshold (GnosisSafe.sol#273) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 295,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function removeOwner(address prevOwner, address owner, uint256 _threshold)\n",
          "message": "Parameter '_threshold' of OwnerManager.removeOwner (GnosisSafe.sol#295) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 339,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function changeThreshold(uint256 _threshold)\n",
          "message": "Parameter '_threshold' of OwnerManager.changeThreshold (GnosisSafe.sol#339) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 398,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function changeMasterCopy(address _masterCopy)\n",
          "message": "Parameter '_masterCopy' of MasterCopy.changeMasterCopy (GnosisSafe.sol#398) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 584,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] calldata _owners,\n",
          "message": "Parameter '_owners' of GnosisSafe.setup (GnosisSafe.sol#584) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 585,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _threshold,\n",
          "message": "Parameter '_threshold' of GnosisSafe.setup (GnosisSafe.sol#585) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 795,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function signMessage(bytes calldata _data)\n",
          "message": "Parameter '_data' of GnosisSafe.signMessage (GnosisSafe.sol#795) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 811,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isValidSignature(bytes calldata _data, bytes calldata _signature)\n",
          "message": "Parameter '_data' of GnosisSafe.isValidSignature (GnosisSafe.sol#811) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 811,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function isValidSignature(bytes calldata _data, bytes calldata _signature)\n",
          "message": "Parameter '_signature' of GnosisSafe.isValidSignature (GnosisSafe.sol#811) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 865,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _nonce\n",
          "message": "Parameter '_nonce' of GnosisSafe.encodeTransactionData (GnosisSafe.sol#865) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 899,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 _nonce\n",
          "message": "Parameter '_nonce' of GnosisSafe.getTransactionHash (GnosisSafe.sol#899) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 139,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address public constant SENTINEL_MODULES = address(0x1);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 234,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address public constant SENTINEL_OWNERS = address(0x1);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 539,
          "vulnerability_to_line": null,
          "vulnerability_code": "    bytes4 constant internal EIP1271_MAGIC_VALUE = 0x20c13b0b;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 181,
          "vulnerability_to_line": null,
          "vulnerability_code": "        modules[address(module)] = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 305,
          "vulnerability_to_line": null,
          "vulnerability_code": "        owners[owner] = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ADDRESS_HARDCODED",
          "vulnerability_from_line": 331,
          "vulnerability_to_line": null,
          "vulnerability_code": "        owners[oldOwner] = address(0);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_ERC20_FUNCTIONS_ALWAYS_RETURN_FALSE",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferToken (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 255,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 210,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while(currentModule != SENTINEL_MODULES) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while(currentModule != SENTINEL_MODULES) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 379,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while(currentOwner != SENTINEL_OWNERS) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 21,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function executeCall(address to, uint256 value, bytes memory data, uint256 txGas)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function executeDelegateCall(address to, bytes memory data, uint256 txGas)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function transferToken (\n",
          "message": null
        },
        {
          "name": "SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN",
          "vulnerability_from_line": 454,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function signatureSplit(bytes memory signatures, uint256 pos)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 255,
          "vulnerability_to_line": null,
          "vulnerability_code": "        for (uint256 i = 0; i < _owners.length; i++) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 210,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while(currentModule != SENTINEL_MODULES) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 219,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while(currentModule != SENTINEL_MODULES) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 379,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while(currentOwner != SENTINEL_OWNERS) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_LOCKED_MONEY",
          "vulnerability_from_line": 84,
          "vulnerability_to_line": null,
          "vulnerability_code": "contract FallbackManager is SelfAuthorized {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRAGMAS_VERSION",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity ^0.5.10;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SAFEMATH",
          "vulnerability_from_line": 545,
          "vulnerability_to_line": null,
          "vulnerability_code": "    using SafeMath for uint256;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_NOT_BE_PURE",
          "vulnerability_from_line": 454,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function signatureSplit(bytes memory signatures, uint256 pos)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 457,
          "vulnerability_to_line": null,
          "vulnerability_code": "        returns (uint8 v, bytes32 r, bytes32 s)\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 26,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 36,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 65,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 92,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 117,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 123,
          "vulnerability_to_line": null,
          "vulnerability_code": "            assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_USING_INLINE_ASSEMBLY",
          "vulnerability_from_line": 463,
          "vulnerability_to_line": null,
          "vulnerability_code": "        assembly {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 583,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setup(\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 237,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint256 ownerCount;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 394,
          "vulnerability_to_line": null,
          "vulnerability_code": "    address masterCopy;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 587,
          "vulnerability_to_line": null,
          "vulnerability_code": "        bytes calldata data,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 588,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address fallbackHandler,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 589,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address paymentToken,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 590,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint256 payment,\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 591,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address payable paymentReceiver\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 595,
          "vulnerability_to_line": null,
          "vulnerability_code": "        require(domainSeparator == 0, \"Domain Separator already set!\");\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 596,
          "vulnerability_to_line": null,
          "vulnerability_code": "        domainSeparator = keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, this));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 596,
          "vulnerability_to_line": null,
          "vulnerability_code": "        domainSeparator = keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, this));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 596,
          "vulnerability_to_line": null,
          "vulnerability_code": "        domainSeparator = keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, this));\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 597,
          "vulnerability_to_line": null,
          "vulnerability_code": "        setupOwners(_owners, _threshold);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 597,
          "vulnerability_to_line": null,
          "vulnerability_code": "        setupOwners(_owners, _threshold);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 599,
          "vulnerability_to_line": null,
          "vulnerability_code": "        setupModules(to, data);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 599,
          "vulnerability_to_line": null,
          "vulnerability_code": "        setupModules(to, data);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 600,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 600,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 600,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 600,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (fallbackHandler != address(0)) internalSetFallbackHandler(fallbackHandler);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 602,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (payment > 0) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 605,
          "vulnerability_to_line": null,
          "vulnerability_code": "            handlePayment(payment, 0, 1, paymentToken, paymentReceiver);\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 605,
          "vulnerability_to_line": null,
          "vulnerability_code": "            handlePayment(payment, 0, 1, paymentToken, paymentReceiver);\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": false,
      "errors": [
        "exception (RuntimeError: Source map error, unknown name(SHR) or instr_name(INVALID))"
      ],
      "vulnerability_findings": []
    },
    "mythril": {
      "successfull_analysis": false,
      "errors": [
        "DOCKER_TIMEOUT"
      ],
      "vulnerability_findings": []
    },
    "osiris": {
      "successfull_analysis": false,
      "errors": [
        "Solidity compilation failed"
      ],
      "vulnerability_findings": []
    }
  }
}