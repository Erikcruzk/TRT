function beginMigration(address targetPool) external onlyPoolAdmin {
    // Before allowing the pool to be migrated, we check that the new pool has at least the same number of reserves
    // as the current one, and that for each reserve in the current pool a corresponding reserve in the same state
    // exists in the target pool.

    uint256 reservesCount = _reservesCount;

    IPool targetPoolContract = IPool(targetPool);
    address[] memory reservesList = targetPoolContract.getReservesList();

    require(reservesList.length >= reservesCount, "TARGET_POOL_MISSING_RESERVES");

    for (uint256 i = 0; i < reservesCount; i++) {
        address asset = _reservesList[i];
        DataTypes.ReserveData memory currentReserveData = _reserves[asset];
        DataTypes.ReserveData memory targetReserveData = targetPoolContract.getReserveData(asset);

        require(currentReserveData.id == targetReserveData.id && 
                keccak256(abi.encodePacked(currentReserveData.aTokenAddress)) == 
                keccak256(abi.encodePacked(targetReserveData.aTokenAddress)) &&
                keccak256(abi.encodePacked(currentReserveData.stableDebtTokenAddress)) == 
                keccak256(abi.encodePacked(targetReserveData.stableDebtTokenAddress)) &&
                keccak256(abi.encodePacked(currentReserveData.variableDebtTokenAddress)) == 
                keccak256(abi.encodePacked(targetReserveData.variableDebtTokenAddress)) &&
                currentReserveData.configuration.data == targetReserveData.configuration.data,
                "TARGET_POOL_RESERVE_CONFIGURATION_MISMATCH");
    }

    _migrationInProgress = true;
    _migrationTargetPool = targetPool;
}