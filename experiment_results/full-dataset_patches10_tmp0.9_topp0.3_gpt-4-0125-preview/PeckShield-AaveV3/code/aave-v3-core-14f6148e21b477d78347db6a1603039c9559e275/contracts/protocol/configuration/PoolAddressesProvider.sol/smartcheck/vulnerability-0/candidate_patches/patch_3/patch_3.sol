pragma solidity 0.8.7;











abstract contract Context {
  function _msgSender() internal view virtual returns (address payable) {
    return payable(msg.sender);
  }

  function _msgData() internal view virtual returns (bytes memory) {
    this; 
    return msg.data;
  }
}





pragma solidity 0.8.7;













contract Ownable is Context {
  address private _owner;

  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

  


  constructor() {
    address msgSender = _msgSender();
    _owner = msgSender;
    emit OwnershipTransferred(address(0), msgSender);
  }

  


  function owner() public view returns (address) {
    return _owner;
  }

  


  modifier onlyOwner() {
    require(_owner == _msgSender(), 'Ownable: caller is not the owner');
    _;
  }

  






  function renounceOwnership() public virtual onlyOwner {
    emit OwnershipTransferred(_owner, address(0));
    _owner = address(0);
  }

  



  function transferOwnership(address newOwner) public virtual onlyOwner {
    require(newOwner != address(0), 'Ownable: new owner is the zero address');
    emit OwnershipTransferred(_owner, newOwner);
    _owner = newOwner;
  }
}




pragma solidity 0.8.7;








abstract contract Proxy {
  




  fallback() external payable {
    _fallback();
  }

  


  function _implementation() internal view virtual returns (address);

  





  function _delegate(address implementation) internal {
    
    assembly {
      
      
      
      calldatacopy(0, 0, calldatasize())

      
      
      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)

      
      returndatacopy(0, 0, returndatasize())

      switch result
      
      case 0 {
        revert(0, returndatasize())
      }
      default {
        return(0, returndatasize())
      }
    }
  }

  




  function _willFallback() internal virtual {}

  



  function _fallback() internal {
    _willFallback();
    _delegate(_implementation());
  }
}




pragma solidity 0.8.7;




library Address {
  
















  function isContract(address account) internal view returns (bool) {
    
    
    
    bytes32 codehash;
    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
    
    assembly {
      codehash := extcodehash(account)
    }
    return (codehash != accountHash && codehash != 0x0);
  }

  















  function sendValue(address payable recipient, uint256 amount) internal {
    require(address(this).balance >= amount, 'Address: insufficient balance');

    
    (bool success, ) = recipient.call{value: amount}('');
    require(success, 'Address: unable to send value, recipient may have reverted');
  }
}




pragma solidity 0.8.7;








contract BaseUpgradeabilityProxy is Proxy {
  



  event Upgraded(address indexed implementation);

  




  bytes32 internal constant IMPLEMENTATION_SLOT =
    0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

  



  function _implementation() internal view override returns (address impl) {
    bytes32 slot = IMPLEMENTATION_SLOT;
    
    assembly {
      impl := sload(slot)
    }
  }

  



  function _upgradeTo(address newImplementation) internal {
    _setImplementation(newImplementation);
    emit Upgraded(newImplementation);
  }

  



  function _setImplementation(address newImplementation) internal {
    require(
      Address.isContract(newImplementation),
      'Cannot set a proxy implementation to a non-contract address'
    );

    bytes32 slot = IMPLEMENTATION_SLOT;

    
    assembly {
      sstore(slot, newImplementation)
    }
  }
}




pragma solidity 0.8.7;






function initialize(address _logic, bytes memory _data) public payable {
  require(_implementation() == address(0), "InitializableUpgradeabilityProxy: already initialized");
  assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));
  _setImplementation(_logic);
  if (_data.length > 0) {
    (bool success, ) = _logic.delegatecall(_data);
    require(success, "InitializableUpgradeabilityProxy: failed to initialize");
  }
}




pragma solidity 0.8.7;











contract BaseImmutableAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {
  address immutable ADMIN;

  constructor(address admin) {
    ADMIN = admin;
  }

  modifier ifAdmin() {
    if (msg.sender == ADMIN) {
      _;
    } else {
      _fallback();
    }
  }

  



  function admin() external ifAdmin returns (address) {
    return ADMIN;
  }

  



  function implementation() external ifAdmin returns (address) {
    return _implementation();
  }

  




  function upgradeTo(address newImplementation) external ifAdmin {
    _upgradeTo(newImplementation);
  }

  








  function upgradeToAndCall(address newImplementation, bytes calldata data)
    external
    payable
    ifAdmin
  {
    _upgradeTo(newImplementation);
    (bool success, ) = newImplementation.delegatecall(data);
    require(success);
  }

  


  function _willFallback() internal virtual override {
    require(msg.sender != ADMIN, 'Cannot call fallback function from the proxy admin');
    super._willFallback();
  }
}




pragma solidity 0.8.7;








contract InitializableImmutableAdminUpgradeabilityProxy is
  BaseImmutableAdminUpgradeabilityProxy,
  InitializableUpgradeabilityProxy
{
  constructor(address admin) BaseImmutableAdminUpgradeabilityProxy(admin) {}

  
  function _willFallback() internal override(BaseImmutableAdminUpgradeabilityProxy, Proxy) {
    BaseImmutableAdminUpgradeabilityProxy._willFallback();
  }
}




pragma solidity 0.8.7;






interface IPoolAddressesProvider {
  event MarketIdSet(string newMarketId);
  event PoolUpdated(address indexed newAddress);
  event PoolConfiguratorUpdated(address indexed newAddress);
  event PriceOracleUpdated(address indexed newAddress);
  event ACLManagerUpdated(address indexed newAddress);
  event ACLAdminUpdated(address indexed newAddress);
  event PriceOracleSentinelUpdated(address indexed newAddress);
  event ProxyCreated(bytes32 id, address indexed newAddress);
  event BridgeAccessControlUpdated(address indexed newAddress);
  event PoolDataProviderUpdated(address indexed newAddress);
  event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);

  



  function getMarketId() external view returns (string memory);

  



  function setMarketId(string calldata marketId) external;

  





  function setAddress(bytes32 id, address newAddress) external;

  








  function setAddressAsProxy(bytes32 id, address impl) external;

  



  function getAddress(bytes32 id) external view returns (address);

  



  function getPool() external view returns (address);

  




  function setPoolImpl(address pool) external;

  



  function getPoolConfigurator() external view returns (address);

  




  function setPoolConfiguratorImpl(address configurator) external;

  function getPriceOracle() external view returns (address);

  function setPriceOracle(address priceOracle) external;

  



  function getACLManager() external view returns (address);

  



  function setACLManager(address aclManager) external;

  



  function getACLAdmin() external view returns (address);

  



  function setACLAdmin(address aclAdmin) external;

  



  function getPriceOracleSentinel() external view returns (address);

  



  function setPriceOracleSentinel(address oracleSentinel) external;

  



  function setPoolDataProvider(address dataProvider) external;

  



  function getPoolDataProvider() external view returns (address);
}




pragma solidity 0.8.7;










contract PoolAddressesProvider is Ownable, IPoolAddressesProvider {
  string private _marketId;
  mapping(bytes32 => address) private _addresses;

  bytes32 private constant POOL = 'POOL';
  bytes32 private constant POOL_CONFIGURATOR = 'POOL_CONFIGURATOR';
  bytes32 private constant PRICE_ORACLE = 'PRICE_ORACLE';
  bytes32 private constant ACL_MANAGER = 'ACL_MANAGER';
  bytes32 private constant ACL_ADMIN = 'ACL_ADMIN';
  bytes32 private constant PRICE_ORACLE_SENTINEL = 'PRICE_ORACLE_SENTINEL';
  bytes32 private constant DATA_PROVIDER = 'DATA_PROVIDER';

  constructor(string memory marketId) {
    _setMarketId(marketId);
  }

  
  function getMarketId() external view override returns (string memory) {
    return _marketId;
  }

  
  function setMarketId(string memory marketId) external override onlyOwner {
    _setMarketId(marketId);
  }

  
  function setAddressAsProxy(bytes32 id, address implementationAddress)
    external
    override
    onlyOwner
  {
    _updateImpl(id, implementationAddress);
    emit AddressSet(id, implementationAddress, true);
  }

  
  function setAddress(bytes32 id, address newAddress) external override onlyOwner {
    _addresses[id] = newAddress;
    emit AddressSet(id, newAddress, false);
  }

  
  function getAddress(bytes32 id) public view override returns (address) {
    return _addresses[id];
  }

  
  function getPool() external view override returns (address) {
    return getAddress(POOL);
  }

  
  function setPoolImpl(address pool) external override onlyOwner {
    _updateImpl(POOL, pool);
    emit PoolUpdated(pool);
  }

  
  function getPoolConfigurator() external view override returns (address) {
    return getAddress(POOL_CONFIGURATOR);
  }

  
  function setPoolConfiguratorImpl(address configurator) external override onlyOwner {
    _updateImpl(POOL_CONFIGURATOR, configurator);
    emit PoolConfiguratorUpdated(configurator);
  }

  function getPriceOracle() external view override returns (address) {
    return getAddress(PRICE_ORACLE);
  }

  function setPriceOracle(address priceOracle) external override onlyOwner {
    _addresses[PRICE_ORACLE] = priceOracle;
    emit PriceOracleUpdated(priceOracle);
  }

  
  function getACLManager() external view override returns (address) {
    return getAddress(ACL_MANAGER);
  }

  
  function setACLManager(address aclManager) external override onlyOwner {
    _addresses[ACL_MANAGER] = aclManager;
    emit ACLManagerUpdated(aclManager);
  }

  
  function getACLAdmin() external view override returns (address) {
    return getAddress(ACL_ADMIN);
  }

  
  function setACLAdmin(address aclAdmin) external override onlyOwner {
    _addresses[ACL_ADMIN] = aclAdmin;
    emit ACLAdminUpdated(aclAdmin);
  }

  
  function setPriceOracleSentinel(address oracleSentinel) external override onlyOwner {
    _addresses[PRICE_ORACLE_SENTINEL] = oracleSentinel;
    emit PriceOracleSentinelUpdated(oracleSentinel);
  }

  
  function getPriceOracleSentinel() external view override returns (address) {
    return getAddress(PRICE_ORACLE_SENTINEL);
  }

  
  function setPoolDataProvider(address dataProvider) external override onlyOwner {
    _addresses[DATA_PROVIDER] = dataProvider;
    emit PoolDataProviderUpdated(dataProvider);
  }

  
  function getPoolDataProvider() external view override returns (address) {
    return getAddress(DATA_PROVIDER);
  }

  








  function _updateImpl(bytes32 id, address newAddress) internal {
    address payable proxyAddress = payable(_addresses[id]);

    InitializableImmutableAdminUpgradeabilityProxy proxy = InitializableImmutableAdminUpgradeabilityProxy(
        proxyAddress
      );
    bytes memory params = abi.encodeWithSignature('initialize(address)', address(this));

    if (proxyAddress == address(0)) {
      proxy = new InitializableImmutableAdminUpgradeabilityProxy(address(this));
      _addresses[id] = address(proxy);
      proxy.initialize(newAddress, params);
      emit ProxyCreated(id, address(proxy));
    } else {
      proxy.upgradeToAndCall(newAddress, params);
    }
  }

  function _setMarketId(string memory marketId) internal {
    _marketId = marketId;
    emit MarketIdSet(marketId);
  }
}