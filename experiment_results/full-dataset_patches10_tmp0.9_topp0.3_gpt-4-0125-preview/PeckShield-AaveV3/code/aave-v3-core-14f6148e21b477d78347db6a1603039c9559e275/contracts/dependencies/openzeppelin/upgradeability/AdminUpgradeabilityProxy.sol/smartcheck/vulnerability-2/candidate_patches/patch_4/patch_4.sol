pragma solidity 0.8.7;








abstract contract Proxy {
  




  fallback() external payable {
    _fallback();
  }

  


  function _implementation() internal view virtual returns (address);

  





  function _delegate(address implementation) internal {
    
    assembly {
      
      
      
      calldatacopy(0, 0, calldatasize())

      
      
      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)

      
      returndatacopy(0, 0, returndatasize())

      switch result
      
      case 0 {
        revert(0, returndatasize())
      }
      default {
        return(0, returndatasize())
      }
    }
  }

  




  function _willFallback() internal virtual {}

  



  function _fallback() internal {
    _willFallback();
    _delegate(_implementation());
  }
}




pragma solidity 0.8.7;




library Address {
  
















  function isContract(address account) internal view returns (bool) {
    
    
    
    bytes32 codehash;
    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
    
    assembly {
      codehash := extcodehash(account)
    }
    return (codehash != accountHash && codehash != 0x0);
  }

  















  function sendValue(address payable recipient, uint256 amount) internal {
    require(address(this).balance >= amount, 'Address: insufficient balance');

    
    (bool success, ) = recipient.call{value: amount}('');
    require(success, 'Address: unable to send value, recipient may have reverted');
  }
}




pragma solidity 0.8.7;








contract BaseUpgradeabilityProxy is Proxy {
  



  event Upgraded(address indexed implementation);

  




  bytes32 internal constant IMPLEMENTATION_SLOT =
    0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

  



  function _implementation() internal view override returns (address impl) {
    bytes32 slot = IMPLEMENTATION_SLOT;
    
    assembly {
      impl := sload(slot)
    }
  }

  



  function _upgradeTo(address newImplementation) internal {
    _setImplementation(newImplementation);
    emit Upgraded(newImplementation);
  }

  



  function _setImplementation(address newImplementation) internal {
    require(
      Address.isContract(newImplementation),
      'Cannot set a proxy implementation to a non-contract address'
    );

    bytes32 slot = IMPLEMENTATION_SLOT;

    
    assembly {
      sstore(slot, newImplementation)
    }
  }
}




pragma solidity 0.8.7;






contract UpgradeabilityProxy is BaseUpgradeabilityProxy {
  







  constructor(address _logic, bytes memory _data) payable {
    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));
    _setImplementation(_logic);
    if (_data.length > 0) {
      (bool success, ) = _logic.delegatecall(_data);
      require(success);
    }
  }
}




pragma solidity 0.8.7;









contract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {
  




  event AdminChanged(address previousAdmin, address newAdmin);

  




  bytes32 internal constant ADMIN_SLOT =
    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;

  




  modifier ifAdmin() {
    if (msg.sender == _admin()) {
      _;
    } else {
      _fallback();
    }
  }

  


  function admin() external ifAdmin returns (address) {
    return _admin();
  }

  


  function implementation() external ifAdmin returns (address) {
    return _implementation();
  }

  




  function changeAdmin(address newAdmin) external ifAdmin {
    require(newAdmin != address(0), 'Cannot change the admin of a proxy to the zero address');
    emit AdminChanged(_admin(), newAdmin);
    _setAdmin(newAdmin);
  }

  




  function upgradeTo(address newImplementation) external ifAdmin {
    _upgradeTo(newImplementation);
  }

  








  function upgradeToAndCall(address newImplementation, bytes calldata data)
    external
    payable
    ifAdmin
  {
    _upgradeTo(newImplementation);
    (bool success, ) = newImplementation.delegatecall(data);
    require(success);
  }

  


  function _admin() internal view returns (address adm) {
    bytes32 slot = ADMIN_SLOT;
    
    assembly {
      adm := sload(slot)
    }
  }

  



  function _setAdmin(address newAdmin) internal {
    bytes32 slot = ADMIN_SLOT;
    
    assembly {
      sstore(slot, newAdmin)
    }
  }

  


  function _willFallback() internal virtual override {
    require(msg.sender != _admin(), 'Cannot call fallback function from the proxy admin');
    super._willFallback();
  }
}




pragma solidity 0.8.7;






// This Solidity snippet does not directly include a function named `beginMigration`. 
// However, to address the issue related to SOLIDITY_LOCKED_MONEY, 
// typically functions to withdraw or rescue funds would be implemented. 
// Since no specific function `beginMigration()` exists or is mentioned in the provided code,
// and the vulnerability highlighted is about locked funds in a proxy contract, 
// below is an illustrative example of how one might implement a function to
// allow the recovery of funds mistakenly sent to the contract.

// NOTE: This is a conceptual illustration. Actual implementation may vary based on the contract's requirements.

function rescueLockedFunds(address payable recipient, uint256 amount) external ifAdmin {
    require(address(this).balance >= amount, "Insufficient balance");
    recipient.transfer(amount);
}