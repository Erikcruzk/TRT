pragma solidity 0.8.7;








abstract contract Proxy {
  




  fallback() external payable {
    _fallback();
  }

  


  function _implementation() internal view virtual returns (address);

  





  function _delegate(address implementation) internal {
    
    assembly {
      
      
      
      calldatacopy(0, 0, calldatasize())

      
      
      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)

      
      returndatacopy(0, 0, returndatasize())

      switch result
      
      case 0 {
        revert(0, returndatasize())
      }
      default {
        return(0, returndatasize())
      }
    }
  }

  




  function _willFallback() internal virtual {}

  



  function _fallback() internal {
    _willFallback();
    _delegate(_implementation());
  }
}




pragma solidity 0.8.7;




library Address {
  
















  function isContract(address account) internal view returns (bool) {
    
    
    
    bytes32 codehash;
    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;
    
    assembly {
      codehash := extcodehash(account)
    }
    return (codehash != accountHash && codehash != 0x0);
  }

  















  function sendValue(address payable recipient, uint256 amount) internal {
    require(address(this).balance >= amount, 'Address: insufficient balance');

    
    (bool success, ) = recipient.call{value: amount}('');
    require(success, 'Address: unable to send value, recipient may have reverted');
  }
}




pragma solidity 0.8.7;








contract BaseUpgradeabilityProxy is Proxy {
  



  event Upgraded(address indexed implementation);

  




  bytes32 internal constant IMPLEMENTATION_SLOT =
    0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

  



  function _implementation() internal view override returns (address impl) {
    bytes32 slot = IMPLEMENTATION_SLOT;
    
    assembly {
      impl := sload(slot)
    }
  }

  



  function _upgradeTo(address newImplementation) internal {
    _setImplementation(newImplementation);
    emit Upgraded(newImplementation);
  }

  



  function _setImplementation(address newImplementation) internal {
    require(
      Address.isContract(newImplementation),
      'Cannot set a proxy implementation to a non-contract address'
    );

    bytes32 slot = IMPLEMENTATION_SLOT;

    
    assembly {
      sstore(slot, newImplementation)
    }
  }
}




pragma solidity 0.8.7;






// The provided contract source does not contain a function explicitly named `beginMigration`. Given the context, it appears there might be some confusion or a mistake in the request. 
// However, considering the analysis and the possible interaction with vulnerabilities and the upgrade mechanism, below is a generic function that would typically be found in such contracts to start a migration or upgrade process.

// Note: This function is crafted based on typical patterns found in upgradeable smart contracts. Since the original prompt does not specify `beginMigration`, the following is an illustrative example based on standard practices:

pragma solidity 0.8.7;

contract AdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, UpgradeabilityProxy {

    // This function would ideally be protected by appropriate access control mechanisms
    function beginMigration(address newImplementation) external ifAdmin {
        // Ensuring that the new implementation address is a contract and not a regular address
        require(Address.isContract(newImplementation), "New implementation must be a contract");

        // Updating the implementation to the new contract
        _upgradeTo(newImplementation);

        // Emitting an upgrade event (optional, but good practice)
        emit Upgraded(newImplementation);
    }
}




pragma solidity 0.8.7;









contract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {
  




  event AdminChanged(address previousAdmin, address newAdmin);

  




  bytes32 internal constant ADMIN_SLOT =
    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;

  




  modifier ifAdmin() {
    if (msg.sender == _admin()) {
      _;
    } else {
      _fallback();
    }
  }

  


  function admin() external ifAdmin returns (address) {
    return _admin();
  }

  


  function implementation() external ifAdmin returns (address) {
    return _implementation();
  }

  




  function changeAdmin(address newAdmin) external ifAdmin {
    require(newAdmin != address(0), 'Cannot change the admin of a proxy to the zero address');
    emit AdminChanged(_admin(), newAdmin);
    _setAdmin(newAdmin);
  }

  




  function upgradeTo(address newImplementation) external ifAdmin {
    _upgradeTo(newImplementation);
  }

  








  function upgradeToAndCall(address newImplementation, bytes calldata data)
    external
    payable
    ifAdmin
  {
    _upgradeTo(newImplementation);
    (bool success, ) = newImplementation.delegatecall(data);
    require(success);
  }

  


  function _admin() internal view returns (address adm) {
    bytes32 slot = ADMIN_SLOT;
    
    assembly {
      adm := sload(slot)
    }
  }

  



  function _setAdmin(address newAdmin) internal {
    bytes32 slot = ADMIN_SLOT;
    
    assembly {
      sstore(slot, newAdmin)
    }
  }

  


  function _willFallback() internal virtual override {
    require(msg.sender != _admin(), 'Cannot call fallback function from the proxy admin');
    super._willFallback();
  }
}




pragma solidity 0.8.7;






contract AdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, UpgradeabilityProxy {
  








  constructor(
    address _logic,
    address _admin,
    bytes memory _data
  ) payable UpgradeabilityProxy(_logic, _data) {
    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));
    _setAdmin(_admin);
  }

  


  function _willFallback() internal override(BaseAdminUpgradeabilityProxy, Proxy) {
    BaseAdminUpgradeabilityProxy._willFallback();
  }
}