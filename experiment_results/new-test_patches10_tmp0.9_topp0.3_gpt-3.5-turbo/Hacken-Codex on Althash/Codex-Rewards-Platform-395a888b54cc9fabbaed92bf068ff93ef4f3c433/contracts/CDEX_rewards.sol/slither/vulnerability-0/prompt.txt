
This Solidity Smart Contract has been analyzed by smart contract analyzers. Here are the results from these analyzers.

slither Analysis Results
Vulnerability: reentrancy-benign found in the following piece of code:

```
    function withdraw(uint256 amount)

        public

        nonReentrant

        updateReward(msg.sender)

    {

        require(amount > 0);

        /// Decrements the total staked balance

        _totalSupply = _totalSupply.sub(amount);

        /// Removes the user address from its current ranking node in the tree

        CDEXRanking.remove(_balances[msg.sender], msg.sender);

        /// Decrements the sender's staked balance

        _balances[msg.sender] = _balances[msg.sender].sub(amount);

        /// If the balance is zero after decremented, decrements the totalMembers

        if(_balances[msg.sender] == 0) {

            totalMembers -= 1;

        } else {

            /// If not, adds the user address back into the ranking tree with the new balance

            CDEXRanking.insert(_balances[msg.sender], msg.sender);

        }

        /// Transfers the tokens into the sender's address

        CDEXToken.transfer(msg.sender, amount);

        /// Emits the event

        emit Withdrawn(msg.sender, amount);

```

The contract is among the source code below:

```
            
            CDEXRanking.insert(amount, msg.sender);
        } else {
            
            CDEXRanking.remove(_balances[msg.sender], msg.sender);
            
            CDEXRanking.insert(_balances[msg.sender].add(amount), msg.sender);
        }
        
        _balances[msg.sender] = _balances[msg.sender].add(amount);
        
        
        bool success = CDEXToken.transferFrom(msg.sender, address(this), amount);
        require(success);
        
        emit Staked(msg.sender, amount);
    }

    
    
    function withdraw(uint256 amount)
        public
        nonReentrant
        updateReward(msg.sender)
    {
        require(amount > 0);
        
        _totalSupply = _totalSupply.sub(amount);
        
        CDEXRanking.remove(_balances[msg.sender], msg.sender);
        
        _balances[msg.sender] = _balances[msg.sender].sub(amount);
        
        if(_balances[msg.sender] == 0) {
            totalMembers -= 1;
        } else {
            
            CDEXRanking.insert(_balances[msg.sender], msg.sender);
        }
        
        CDEXToken.transfer(msg.sender, amount);
        
        emit Withdrawn(msg.sender, amount);
    }
    
    
    function getReward() 
        public 
        nonReentrant 
        updateReward(msg.sender) 
    {
        uint256 reward = rewards[msg.sender];
        
        if (reward > 0 && committedRewardTokens >= reward) {
            uint256 loyaltyBonus = loyaltyBonuses[msg.sender];
            
            rewards[msg.sender] = 0;
            loyaltyBonuses[msg.sender] = 0;
            
            committedRewardTokens = committedRewardTokens.sub(reward);
            
            depositedLoyaltyBonus = depositedLoyaltyBonus.sub(loyaltyBonus);
            
            CDEXToken.transfer(msg.sender, reward.add(loyaltyBonus));
```

Recommended fix: check-effects-interactions pattern

DO NOT return natural language for explanations, only the Solidity code of the vulnerable function (if it is a function otherwise whole contract). 