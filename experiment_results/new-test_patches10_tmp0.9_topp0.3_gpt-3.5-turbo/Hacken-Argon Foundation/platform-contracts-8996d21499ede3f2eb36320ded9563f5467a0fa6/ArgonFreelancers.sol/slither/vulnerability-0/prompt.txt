
This Solidity Smart Contract has been analyzed by smart contract analyzers. Here are the results from these analyzers.

slither Analysis Results
Vulnerability: reentrancy-benign found in the following piece of code:

```
    function addPerson(uint8 _accountType, string _personInfoData)

        external

        mustActive

        nonReentrant

    {

        if (_accountType == 1) {

            approverLockBalances[msg.sender] = approverLockBalances[msg.sender]

                .safeAdd(approverMinArgonLimit);

            require(

                argonToken.transferFrom(

                    msg.sender,

                    address(this),

                    approverMinArgonLimit

                )

            );

        }

        require(!personsAddress[msg.sender]);

        AccountData memory newAccount =

            AccountData({

                accountType: _accountType,

                personWalletAddress: msg.sender,

                personWorkCount: 0,

                personPuan: new uint256[](0),

                WorkAddresses: new address[](0),

                personInfoData: _personInfoData

            });



        accounts[msg.sender] = newAccount; // Adding a new account

        allPersons.push(msg.sender); // Adding a new account

        personsAddress[msg.sender] = true;

```

The contract is among the source code below:

```

    function unLock() external mustApprover nonReentrant {
        require(approverLockBalances[msg.sender] > 0);
        AccountData storage data = accounts[msg.sender];
        require(data.WorkAddresses.length == 0);
        delete accounts[msg.sender];
        personsAddress[msg.sender] = false;
        for (uint256 x = 0; x < allPersons.length; x++) {
            if (allPersons[x] == msg.sender) {
                delete allPersons[x];
            }
        }
        argonToken.transfer(msg.sender, approverLockBalances[msg.sender]);
        approverLockBalances[msg.sender] = 0;
    }

    function getAllPersons() external view returns (address[]) {
        return allPersons;
    }

    function addPerson(uint8 _accountType, string _personInfoData)
        external
        mustActive
        nonReentrant
    {
        if (_accountType == 1) {
            approverLockBalances[msg.sender] = approverLockBalances[msg.sender]
                .safeAdd(approverMinArgonLimit);
            require(
                argonToken.transferFrom(
                    msg.sender,
                    address(this),
                    approverMinArgonLimit
                )
            );
        }
        require(!personsAddress[msg.sender]);
        AccountData memory newAccount =
            AccountData({
                accountType: _accountType,
                personWalletAddress: msg.sender,
                personWorkCount: 0,
                personPuan: new uint256[](0),
                WorkAddresses: new address[](0),
                personInfoData: _personInfoData
            });

        accounts[msg.sender] = newAccount; 
        allPersons.push(msg.sender); 
        personsAddress[msg.sender] = true;
    }

    function getPersonInfoData(address _personAddress)
        external
        view
        returns (
            uint8,
            uint256,
            uint256[],
            address[],
            string
        )
    {
        AccountData storage data = accounts[_personAddress];
        return (
            data.accountType,
            data.personWorkCount,
            data.personPuan,
            data.WorkAddresses,
            data.personInfoData
        );
```

Recommended fix: check-effects-interactions pattern

DO NOT return natural language for explanations, only the Solidity code of the vulnerable function (if it is a function otherwise whole contract). 