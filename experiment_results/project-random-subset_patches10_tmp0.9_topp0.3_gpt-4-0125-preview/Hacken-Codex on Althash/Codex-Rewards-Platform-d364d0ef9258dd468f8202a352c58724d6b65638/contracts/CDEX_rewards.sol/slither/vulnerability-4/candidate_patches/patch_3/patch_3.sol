pragma solidity ^0.4.21;





contract ReentrancyGuard {
    












    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    uint256 private _status;

    function ReentrancyGuard() internal {
        _status = _NOT_ENTERED;
    }

    






    modifier nonReentrant() {
        
        require(_status != _ENTERED);
        
        _status = _ENTERED;

        _;

        
        
        _status = _NOT_ENTERED;
    }
}

contract Owned {
    address public owner;
    address public nominatedOwner;

    function Owned(address _owner) public {
        require(_owner != address(0));
        owner = _owner;
        emit OwnerChanged(address(0), _owner);
    }

    function nominateNewOwner(address _owner) external onlyOwner {
        nominatedOwner = _owner;
        emit OwnerNominated(_owner);
    }

    function acceptOwnership() external {
        require(msg.sender == nominatedOwner);
        emit OwnerChanged(owner, nominatedOwner);
        owner = nominatedOwner;
        nominatedOwner = address(0);
    }

    modifier onlyOwner {
        _onlyOwner();
        _;
    }

    function _onlyOwner() private view {
        require(msg.sender == owner);
    }

    event OwnerNominated(address newOwner);
    event OwnerChanged(address oldOwner, address newOwner);
}

contract Pausable is Owned {
    uint256 public lastPauseTime;
    bool public paused;

    function Pausable() internal {
        
        require(owner != address(0));
        
    }

    



    function setPaused(bool _paused) external onlyOwner {
        
        if (_paused == paused) {
            return;
        }

        
        paused = _paused;
        
        if (paused) {
            lastPauseTime = now;
        }
        
        emit PauseChanged(paused);
    }

    event PauseChanged(bool isPaused);

    modifier notPaused {
        require(!paused);
        _;
    }
}

library SafeMath {
    









    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    









    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    









    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        
        
        
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    











    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0);
        uint256 c = a / b;

        return c;
    }

    











    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}


interface CDEXTokenContract {

    function balanceOf(address account) external view returns (uint256);
    function transfer(address _to, uint256 _value) external;
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);

}


interface CDEXRankingContract {

    function insert(uint _key, address _value) external;
    function remove(uint _key, address _value) external;

}

function getReward() 
    public 
    nonReentrant 
    updateReward(msg.sender) 
{
    uint256 reward = rewards[msg.sender];
    uint256 loyaltyBonus = 0; // Initialize the loyaltyBonus variable
    
    if (reward > 0 && depositedRewardTokens >= reward) {
        
        rewards[msg.sender] = 0;
        
        depositedRewardTokens = depositedRewardTokens.sub(reward);
        
        if (_balances[msg.sender] >= loyaltyTier1) {
            loyaltyBonus = reward.mul(loyaltyTier1Bonus).div(10000);
        } else if (_balances[msg.sender] >= loyaltyTier2) {
            loyaltyBonus = reward.mul(loyaltyTier2Bonus).div(10000);
        } else if (_balances[msg.sender] >= loyaltyTier3) {
            loyaltyBonus = reward.mul(loyaltyTier3Bonus).div(10000);
        }
        
        depositedLoyaltyBonus = depositedLoyaltyBonus.sub(loyaltyBonus);
        
        CDEXToken.transfer(msg.sender, reward.add(loyaltyBonus));
        
        emit RewardPaid(msg.sender, reward);
        
        if(loyaltyBonus > 0) {
            emit LoyaltyBonusPaid(msg.sender, loyaltyBonus);
        }
    }
}