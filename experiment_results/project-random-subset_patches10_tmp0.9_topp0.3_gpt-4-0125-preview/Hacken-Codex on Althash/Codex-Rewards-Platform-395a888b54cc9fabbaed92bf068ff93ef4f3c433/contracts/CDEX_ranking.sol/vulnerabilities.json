{
  "smartbugs_completed": true,
  "analyzer_results": {
    "semgrep": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "array-length-outside-loop",
          "vulnerability_from_line": 427,
          "vulnerability_to_line": null,
          "vulnerability_code": "            while (j < values[aux].length && i < _positions) {\n",
          "message": "Caching the array length outside a loop saves reading it on each iteration, as long as the array's length is not changed during the loop."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 427,
          "vulnerability_to_line": null,
          "vulnerability_code": "            while (j < values[aux].length && i < _positions) {\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "state-variable-read-in-a-loop",
          "vulnerability_from_line": 428,
          "vulnerability_to_line": null,
          "vulnerability_code": "                _addresses[i] = values[aux][j];\n",
          "message": "Replace state variable reads and writes within loops with local variable reads and writes."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 275,
          "vulnerability_to_line": null,
          "vulnerability_code": "                if (!self.nodes[self.nodes[cursor].left].red && !self.nodes[self.nodes[cursor].right].red) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 276,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    self.nodes[cursor].red = true;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 277,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    key = keyParent;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 278,
          "vulnerability_to_line": null,
          "vulnerability_code": "                } else {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 279,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    if (!self.nodes[self.nodes[cursor].right].red) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 280,
          "vulnerability_to_line": null,
          "vulnerability_code": "                        self.nodes[self.nodes[cursor].left].red = false;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 281,
          "vulnerability_to_line": null,
          "vulnerability_code": "                        self.nodes[cursor].red = true;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 282,
          "vulnerability_to_line": null,
          "vulnerability_code": "                        rotateRight(self, cursor);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 283,
          "vulnerability_to_line": null,
          "vulnerability_code": "                        cursor = self.nodes[keyParent].right;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 284,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 299,
          "vulnerability_to_line": null,
          "vulnerability_code": "                if (!self.nodes[self.nodes[cursor].right].red && !self.nodes[self.nodes[cursor].left].red) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 300,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    self.nodes[cursor].red = true;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 301,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    key = keyParent;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 302,
          "vulnerability_to_line": null,
          "vulnerability_code": "                } else {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 303,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    if (!self.nodes[self.nodes[cursor].left].red) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 304,
          "vulnerability_to_line": null,
          "vulnerability_code": "                        self.nodes[self.nodes[cursor].right].red = false;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 305,
          "vulnerability_to_line": null,
          "vulnerability_code": "                        self.nodes[cursor].red = true;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 306,
          "vulnerability_to_line": null,
          "vulnerability_code": "                        rotateLeft(self, cursor);\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 307,
          "vulnerability_to_line": null,
          "vulnerability_code": "                        cursor = self.nodes[keyParent].left;\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 308,
          "vulnerability_to_line": null,
          "vulnerability_code": "                    }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 384,
          "vulnerability_to_line": null,
          "vulnerability_code": "        if (tree.exists(_key) && values[_key].length - 1 >= _pos) {\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 385,
          "vulnerability_to_line": null,
          "vulnerability_code": "            value = values[_key][_pos];\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-nested-if",
          "vulnerability_from_line": 386,
          "vulnerability_to_line": null,
          "vulnerability_code": "        }\n",
          "message": "Using nested is cheaper than using && multiple check combinations. There are more advantages, such as easier to read code and better coverage reports."
        },
        {
          "name": "use-prefix-decrement-not-postfix",
          "vulnerability_from_line": 415,
          "vulnerability_to_line": null,
          "vulnerability_code": "        values[_key].length--;\n",
          "message": "Consider using the prefix decrement expression whenever the return value is not needed. The prefix decrement expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 430,
          "vulnerability_to_line": null,
          "vulnerability_code": "                i++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        },
        {
          "name": "use-prefix-increment-not-postfix",
          "vulnerability_from_line": 431,
          "vulnerability_to_line": null,
          "vulnerability_code": "                j++;\n",
          "message": "Consider using the prefix increment expression whenever the return value is not needed. The prefix increment expression is cheaper in terms of gas."
        }
      ]
    },
    "slither": {
      "successfull_analysis": true,
      "errors": [
        "EXIT_CODE_23"
      ],
      "vulnerability_findings": [
        {
          "name": "uninitialized-local",
          "vulnerability_from_line": 423,
          "vulnerability_to_line": null,
          "vulnerability_code": "        uint i;\n",
          "message": "i in CDEXRanking.ranking (CDEX_ranking.sol#423) is a local variable never initialiazed\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 349,
          "vulnerability_to_line": 351,
          "vulnerability_code": "    function getValuesLength(uint _value) public view returns (uint length) {\n\n        length = values[_value].length;\n",
          "message": "CDEXRanking.getValuesLength (CDEX_ranking.sol#349-351) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 353,
          "vulnerability_to_line": 355,
          "vulnerability_code": "    function root() public view returns (uint _key) {\n\n        _key = tree.root;\n",
          "message": "CDEXRanking.root (CDEX_ranking.sol#353-355) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 357,
          "vulnerability_to_line": 359,
          "vulnerability_code": "    function first() public view returns (uint _key) {\n\n        _key = tree.first();\n",
          "message": "CDEXRanking.first (CDEX_ranking.sol#357-359) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 365,
          "vulnerability_to_line": 367,
          "vulnerability_code": "    function next(uint key) public view returns (uint _key) {\n\n        _key = tree.next(key);\n",
          "message": "CDEXRanking.next (CDEX_ranking.sol#365-367) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 373,
          "vulnerability_to_line": 375,
          "vulnerability_code": "    function exists(uint key) public view returns (bool _exists) {\n\n        _exists = tree.exists(key);\n",
          "message": "CDEXRanking.exists (CDEX_ranking.sol#373-375) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": 381,
          "vulnerability_code": "    function getNode(uint _key) public view returns (uint key, uint parent, uint left, uint right, bool red) {\n\n        if (tree.exists(_key)) {\n\n            (key, parent, left, right, red) = tree.getNode(_key);\n\n        }\n",
          "message": "CDEXRanking.getNode (CDEX_ranking.sol#377-381) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 383,
          "vulnerability_to_line": 387,
          "vulnerability_code": "    function getValue(uint _key, uint _pos) public view returns (address value) {\n\n        if (tree.exists(_key) && values[_key].length - 1 >= _pos) {\n\n            value = values[_key][_pos];\n\n        }\n",
          "message": "CDEXRanking.getValue (CDEX_ranking.sol#383-387) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 389,
          "vulnerability_to_line": 397,
          "vulnerability_code": "    function insert(uint _key, address _value) public {\n\n        require(msg.sender == codexStakingContract || msg.sender == owner);\n\n        if (!tree.exists(_key)) {\n\n            tree.insert(_key);\n\n        }\n\n        values[_key].push(_value);\n\n        addressPosition[_value] = values[_key].length - 1;\n\n        emit Log(\"insert\", _key, _value);\n",
          "message": "CDEXRanking.insert (CDEX_ranking.sol#389-397) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 399,
          "vulnerability_to_line": 417,
          "vulnerability_code": "    function remove(uint _key, address _value) public {\n\n        require(msg.sender == codexStakingContract || msg.sender == owner);\n\n        require(values[_key][addressPosition[_value]] == _value);\n\n        if (values[_key].length == 1) {\n\n            tree.remove(_key);\n\n        } else {\n\n            if (addressPosition[_value] != values[_key].length - 1) {\n\n                address movingValue = values[_key][values[_key].length - 1];\n\n                // Copying the last address in the array to the position of the address to be removed\n\n                values[_key][addressPosition[_value]] = movingValue;\n\n                // Updating the position reference for the moved value\n\n                addressPosition[movingValue] = addressPosition[_value];\n\n            }\n\n        }\n\n        emit Log(\"remove\", _key, values[_key][addressPosition[_value]]);\n\n        // Deleting the last position of the array\n\n        values[_key].length--;\n\n        addressPosition[_value] = 0;\n",
          "message": "CDEXRanking.remove (CDEX_ranking.sol#399-417) should be declared external\n"
        },
        {
          "name": "external-function",
          "vulnerability_from_line": 419,
          "vulnerability_to_line": 436,
          "vulnerability_code": "    function ranking(uint _positions) public view returns (address[] memory, uint256[] memory) {\n\n        address[] memory _addresses = new address[](_positions);\n\n        uint256[] memory _balances = new uint256[](_positions);\n\n        uint aux = last();\n\n        uint i;\n\n        uint j;\n\n        while (i < _positions) {\n\n            j = 0;\n\n            while (j < values[aux].length && i < _positions) {\n\n                _addresses[i] = values[aux][j];\n\n                _balances[i] = aux;\n\n                i++;\n\n                j++;\n\n            }\n\n            aux = prev(aux);\n\n        }\n\n        return (_addresses, _balances);\n",
          "message": "CDEXRanking.ranking (CDEX_ranking.sol#419-436) should be declared external\n"
        },
        {
          "name": "solc-version",
          "vulnerability_from_line": 3,
          "vulnerability_to_line": null,
          "vulnerability_code": "pragma solidity 0.4.21;\n",
          "message": "Detected issues with version pragma in CDEX_ranking.sol:\n\t- pragma solidity0.4.21 (CDEX_ranking.sol#3): it allows old versions\n\t- pragma solidity0.4.21 (CDEX_ranking.sol#326): it allows old versions\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 340,
          "vulnerability_to_line": 342,
          "vulnerability_code": "    function CDEXRanking() public {\n\n        owner = msg.sender;\n",
          "message": "Function 'CDEXRanking.CDEXRanking' (CDEX_ranking.sol#340-342) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 344,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setCodexContractAddress(address _contractAddress) external {\n",
          "message": "Parameter '_contractAddress' of CDEXRanking.setCodexContractAddress (CDEX_ranking.sol#344) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 349,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getValuesLength(uint _value) public view returns (uint length) {\n",
          "message": "Parameter '_value' of CDEXRanking.getValuesLength (CDEX_ranking.sol#349) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 377,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getNode(uint _key) public view returns (uint key, uint parent, uint left, uint right, bool red) {\n",
          "message": "Parameter '_key' of CDEXRanking.getNode (CDEX_ranking.sol#377) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 383,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getValue(uint _key, uint _pos) public view returns (address value) {\n",
          "message": "Parameter '_key' of CDEXRanking.getValue (CDEX_ranking.sol#383) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 383,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getValue(uint _key, uint _pos) public view returns (address value) {\n",
          "message": "Parameter '_pos' of CDEXRanking.getValue (CDEX_ranking.sol#383) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 389,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function insert(uint _key, address _value) public {\n",
          "message": "Parameter '_key' of CDEXRanking.insert (CDEX_ranking.sol#389) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 389,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function insert(uint _key, address _value) public {\n",
          "message": "Parameter '_value' of CDEXRanking.insert (CDEX_ranking.sol#389) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 399,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function remove(uint _key, address _value) public {\n",
          "message": "Parameter '_key' of CDEXRanking.remove (CDEX_ranking.sol#399) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 399,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function remove(uint _key, address _value) public {\n",
          "message": "Parameter '_value' of CDEXRanking.remove (CDEX_ranking.sol#399) is not in mixedCase\n"
        },
        {
          "name": "naming-convention",
          "vulnerability_from_line": 419,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function ranking(uint _positions) public view returns (address[] memory, uint256[] memory) {\n",
          "message": "Parameter '_positions' of CDEXRanking.ranking (CDEX_ranking.sol#419) is not in mixedCase\n"
        }
      ]
    },
    "smartcheck": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "SOLIDITY_ARRAY_LENGTH_MANIPULATION",
          "vulnerability_from_line": 415,
          "vulnerability_to_line": null,
          "vulnerability_code": "        values[_key].length--;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_EXTRA_GAS_IN_LOOPS",
          "vulnerability_from_line": 427,
          "vulnerability_to_line": null,
          "vulnerability_code": "            while (j < values[aux].length && i < _positions) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 36,
          "vulnerability_to_line": null,
          "vulnerability_code": "            while (self.nodes[_key].left != EMPTY) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 44,
          "vulnerability_to_line": null,
          "vulnerability_code": "            while (self.nodes[_key].right != EMPTY) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 55,
          "vulnerability_to_line": null,
          "vulnerability_code": "            while (cursor != EMPTY && target == self.nodes[cursor].right) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 67,
          "vulnerability_to_line": null,
          "vulnerability_code": "            while (cursor != EMPTY && target == self.nodes[cursor].left) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 92,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (probe != EMPTY) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 119,
          "vulnerability_to_line": null,
          "vulnerability_code": "            while (self.nodes[cursor].left != EMPTY) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 156,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (self.nodes[key].left != EMPTY) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 162,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (self.nodes[key].right != EMPTY) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 209,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (key != self.root && self.nodes[self.nodes[key].parent].red) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 265,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (key != self.root && !self.nodes[key].red) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 425,
          "vulnerability_to_line": null,
          "vulnerability_code": "        while (i < _positions) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
          "vulnerability_from_line": 427,
          "vulnerability_to_line": null,
          "vulnerability_code": "            while (j < values[aux].length && i < _positions) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_OVERPOWERED_ROLE",
          "vulnerability_from_line": 344,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function setCodexContractAddress(address _contractAddress) external {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_PRIVATE_MODIFIER_DONT_HIDE_DATA",
          "vulnerability_from_line": 31,
          "vulnerability_to_line": null,
          "vulnerability_code": "    uint private constant EMPTY = 0;\n",
          "message": null
        },
        {
          "name": "SOLIDITY_SHOULD_RETURN_STRUCT",
          "vulnerability_from_line": 82,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function getNode(Tree storage self, uint key) internal view returns (uint _returnKey, uint _parent, uint _left, uint _right, bool _red) {\n",
          "message": null
        },
        {
          "name": "SOLIDITY_VISIBILITY",
          "vulnerability_from_line": 331,
          "vulnerability_to_line": null,
          "vulnerability_code": "    BokkyPooBahsRedBlackTreeLibrary.Tree tree;\n",
          "message": null
        }
      ]
    },
    "oyente": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Integer Overflow",
          "vulnerability_from_line": 394,
          "vulnerability_to_line": null,
          "vulnerability_code": "        values[_key].push(_value);\n",
          "message": null
        }
      ]
    },
    "mythril": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 399,
          "vulnerability_to_line": null,
          "vulnerability_code": "    function remove(uint _key, address _value) public {\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        },
        {
          "name": "Exception State (SWC 110)",
          "vulnerability_from_line": 332,
          "vulnerability_to_line": null,
          "vulnerability_code": "    mapping(uint => address[]) public values;\n",
          "message": "An assertion violation was triggered.\nIt is possible to trigger an assertion violation. Note that Solidity assert() statements should only be used to check invariants. Review the transaction trace generated for this issue and either make sure your program logic is correct, or use require() instead of assert() if your goal is to constrain user inputs or enforce preconditions. Remember to validate inputs from both callers (for instance, via passed arguments) and callees (for instance, via return values).\nClassification: SWC-110"
        }
      ]
    },
    "osiris": {
      "successfull_analysis": true,
      "errors": [],
      "vulnerability_findings": [
        {
          "name": "Overflow bugs",
          "vulnerability_from_line": 420,
          "vulnerability_to_line": null,
          "vulnerability_code": "        address[] memory _addresses = new address[](_positions);\n",
          "message": null
        },
        {
          "name": "Underflow bugs",
          "vulnerability_from_line": 395,
          "vulnerability_to_line": null,
          "vulnerability_code": "        addressPosition[_value] = values[_key].length - 1;\n",
          "message": null
        }
      ]
    }
  }
}