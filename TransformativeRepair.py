import json
import logging
import os
import threading
import time
import traceback
import networkx as nx
from pyvis.network import Network
from SmartContract import SmartContract
from PromptEngine import PromptEngine
from networkx.readwrite import json_graph
from typing import List
from pathlib import Path
import queue
import shutil
from tqdm import tqdm


class TransformativeRepair:
    
    def __init__(self, experiment_settings:dict, llm_settings:dict) -> None:
        self.experiment_settings = experiment_settings
        self.llm_settings = llm_settings

        self.experiments_dir:str = f'experiment_results/{experiment_settings["experiment_name"]}_{experiment_settings["llm_model"]}'
        self.vulnerable_contracts_dir:str = experiment_settings["vulnerable_contracts_directory"]
        self.target_vulnerabilities:List[str] = experiment_settings["target_vulnerabilities"]
        self.patch_examples_dir:str = experiment_settings["patch_examples_directory"]
        self.smartbugs_tools:List[str] = experiment_settings["smartbugs_tools"]
        
        self.prompt_style:str = experiment_settings["prompt_style"]
        self.llm_model:str = experiment_settings["llm_model"]
        self.llm_settings:dict = llm_settings

        self.smartbugs_sc_queue = queue.Queue()
        self.repair_sc_queue = queue.Queue()

    def show_prompt_styles(self, sc_path:str):
        """
        Displays example prompts generated by the PromptEngine for a given Solidity smart contract.

        This function takes a file path to a Solidity smart contract as a parameter, creates an instance of the SmartContract class with the file path, sets its vulnerabilities attribute to a dictionary of detected vulnerabilities, and then creates a PromptEngine instance with the SmartContract instance as a parameter.

        The function then generates and displays three types of prompts using the PromptEngine's generate_prompt() method, each identified by a string parameter: "A_basic", "B_vulnerability_context", and "C_vulnerability_examples". The generated prompts are printed to the console.

        Note: Vulnerability detection tools are not used in this demo function.

        Args:
        - sc_path (str): a string representing the file path to the Solidity smart contract to be analyzed

        """
        sc = SmartContract(sc_path)
        sc.vulnerabilities = {'oyente': ['reentrancy', 'reentrancy']}

        pe = PromptEngine(sc)
        print(f'A_basic\n\n{pe.generate_prompt("A_basic")}\n\n')
        print(f'B_vulnerability_context\n\n{pe.generate_prompt("B_vulnerability_context")}\n\n')
        print(f'C_vulnerability_examples\n\n{pe.generate_prompt("C_vulnerability_examples")}\n\n')
    
    # Visualize
    @staticmethod
    def save_graph(G:nx.DiGraph, results_path:str):
        nt = Network('800', '100%', directed=True)
        nt.from_nx(G)
        # nt.show_buttons(filter_=['physics'])
        nt.set_options('''{
        "physics": {
            "forceAtlas2Based": {
            "theta": 0.1,
            "gravitationalConstant": -104,
            "springLength": 0,
            "springConstant": 0.5,
            "damping": 1,
            "avoidOverlap": 1
            },
            "maxVelocity": 85,
            "minVelocity": 10,
            "solver": "forceAtlas2Based",
            "timestep": 0.1
        },
        "layout":{
            "randomSeed":2
            }
        }''')
        
        os.makedirs(os.path.dirname(f'{results_path}.html'), exist_ok=True)
        nt.write_html(f'{results_path}.html')
        
        # Save to Json
        data = json_graph.node_link_data(G)
        with open(f'{results_path}.json', 'w') as outfile:
            json.dump(data, outfile)    
    
    @staticmethod
    def get_repaired_vulnerabilities(original_vulnerabilities:dict, patch_vulnerabilities:dict) -> dict:
        try:
            repaired_vulnerabilities = {}
            all_tool_repair = True
            for tool, tool_vulnerabilities in patch_vulnerabilities.items():
                if('error' in tool_vulnerabilities):
                    repaired_vulnerabilities[tool] = tool_vulnerabilities
                    all_tool_repair = False
                    continue

                #repaired_vulnerabilities[tool] = [x for x in original_vulnerabilities[tool] if x not in tool_vulnerabilities]

                repaired_vulnerabilities[tool] = [x for x in original_vulnerabilities[tool] + tool_vulnerabilities if x not in original_vulnerabilities[tool] or x not in tool_vulnerabilities]
                if tool_vulnerabilities:
                    all_tool_repair = False
            
            return repaired_vulnerabilities, all_tool_repair
        except Exception as e:
            logging.critical("An exception occurred: %s", str(e), exc_info=True)
            return {"error": str(e), 'stacktrace': traceback.format_exc()}
    
    @staticmethod
    def create_summary(experiment_settings:dict, llm_settings:dict, stop_event:threading.Event=None, finished=False):

        G = nx.DiGraph()
        summary = {}

        results_dir = Path(os.path.join("experiment_results",
            f'{experiment_settings["experiment_name"]}_{experiment_settings["llm_model"]}'))
        
        # Loop that checks that all patches have got their vulnerablities.json => they are done
        while not finished:
            time.sleep(3)
            try:
                finished = True
                for sc_dir in [os.path.join(results_dir, item) for item in os.listdir(results_dir) if os.path.isdir(os.path.join(results_dir, item))]:
                    candidate_patches_path = os.path.join(sc_dir, "candidate_patches")
                    for patch_dir in [os.path.join(candidate_patches_path, item) for item in os.listdir(candidate_patches_path) if os.path.isdir(os.path.join(candidate_patches_path, item))]:
                        if "vulnerabilities.json" not in os.listdir(patch_dir):
                            finished = False
                if finished:
                    break

            except Exception as e:
                finished = False
                continue
                logging.warning("An exception occurred: %s", str(e), exc_info=True)              

        # Create summary
        for sc_dir in [os.path.join(results_dir, item) for item in os.listdir(results_dir) if os.path.isdir(os.path.join(results_dir, item))]:
            
            sc_name = os.path.basename(sc_dir)
            # Create Network
            # Add START node
            G.add_node(sc_name, 
                # sc_data=start_sc, 
                group=1, 
                size=30)

            summary[sc_name] = {}
            summary[sc_name]["plausible_patches"] = 0
            summary[sc_name]["repaired_vulnerability"] = []
            with open(os.path.join(sc_dir, "vulnerabilities.json")) as f:
                original_vulnerabilities = json.load(f)
                candidate_patches_dir = os.path.join(sc_dir, 'candidate_patches')
            for patch_name in os.listdir(candidate_patches_dir):
                patch_node_name = f'{sc_name}_{patch_name}'
                patch_vulnerabilities_file = os.path.join(candidate_patches_dir, patch_name, 'vulnerabilities.json')
                with open(patch_vulnerabilities_file) as f:
                    patch_vulnerabilities = json.load(f)
                
                repaired_vulnerabilities_dict, all_tool_repair = TransformativeRepair.get_repaired_vulnerabilities(original_vulnerabilities, patch_vulnerabilities)
                
                if all_tool_repair:
                    summary[sc_name]["plausible_patches"] += 1
                    summary[sc_name]["repaired_vulnerability"] = list(set(summary[sc_name]["repaired_vulnerability"] + [v for sublist in repaired_vulnerabilities_dict.values() for item in sublist for v in (item if isinstance(item, list) else [item])]))
                    G.add_node(patch_node_name,
                        color="green")
                else:
                    G.add_node(patch_node_name, 
                        color="red")
                
                G.add_edge(sc_name, patch_node_name)
                
        
        with open(os.path.join(results_dir, "summary_experiment.json"), "w") as outfile:
            outfile.write(json.dumps(summary))
        
        TransformativeRepair.save_graph(G, results_dir)        

        # Stop all threads and finish program
        for thread in threading.enumerate():
            if thread != threading.main_thread():
                stop_event.set()


    
    @staticmethod
    def find_vulnerabilities(experiment_settings:dict, sc_path:Path, do_repair_sc:bool, repair_sc_queue:queue.Queue) -> None:

        try:
            #### Step 1: Initialize SC
            sc = SmartContract(experiment_settings, sc_path)

            #### Step 2: Find Vulnerabilities
            sc.run_smartbugs()

            #### Step 3: Enqueue to repair queue
            if do_repair_sc:
                repair_sc_queue.put(sc.path)
        except Exception as e:
            logging.critical(f'An exception occurred when finding vulnerabilities for contract={sc_path}: {str(e)}', exc_info=True)            


    @staticmethod
    def consumer_of_vulnerabilities_queue(experiment_setting:dict, smartbugs_sc_queue:queue.Queue, repair_sc_queue:queue.Queue, stop_event:threading.Event, progressbar:tqdm) -> None:

        while not stop_event.is_set():
            try:
                sc_path, do_repair_sc = smartbugs_sc_queue.get(block=False)
                TransformativeRepair.find_vulnerabilities(experiment_setting, sc_path, do_repair_sc, repair_sc_queue)
                progressbar.update(1)
            except queue.Empty:
                time.sleep(10)


    @staticmethod
    def repair_sc(experiment_settings:dict, llm_settings:dict, sc_path:str, smartbugs_sc_queue:queue.Queue):
        

        #### Step 1: Initialize SC
        sc = SmartContract(experiment_settings, sc_path)
        
        # Check if repair already done successfull
        results_0_dir = Path(os.path.join(sc.results_dir, "candidate_patches"))
        if results_0_dir.exists():
            return # vulnerabilities already found TODO: check results file      

        #### Step 2: Create Prompt Engine and generate prompt
        pe = PromptEngine(sc)
        prompt = pe.generate_prompt(experiment_settings)

        #### Step 3: Save prompt
        with open(os.path.join(sc.results_dir, "prompt.txt"), 'w') as file:
            file.write(prompt)
        
        #### Step 4: Repair smart contract
        model_name = experiment_settings["llm_model"]
        candidate_patches_paths = []
        if model_name == "gpt-3.5-turbo":
            candidate_patches_paths = pe.get_codex_repaired_sc(experiment_settings, llm_settings[model_name], sc, prompt)
        else:
            raise KeyError(f'model_name={model_name} not found!')
        
        #### Step 5: Add to find vulnerabilities queue
        for candidate_patch_path in candidate_patches_paths:
            smartbugs_sc_queue.put((candidate_patch_path, False))


    @staticmethod
    def consumer_of_repair_queue(experiment_setting:dict, llm_settings:dict, smartbugs_sc_queue:queue.Queue, repair_sc_queue:queue.Queue, stop_event:threading.Event):
        while not stop_event.is_set():
            try:
                sc_path = repair_sc_queue.get(block=False)
                TransformativeRepair.repair_sc(experiment_setting, llm_settings, sc_path, smartbugs_sc_queue)
            except queue.Empty:
                time.sleep(10)
    
    def start(self):
        
        #### Step 1: Add all vulnerable sc to smartbugs_sc_queue
        results_dir = Path(os.path.join("experiment_results",
                f'{self.experiment_settings["experiment_name"]}_{self.experiment_settings["llm_model"]}'))
        results_dir.mkdir(parents=True, exist_ok=True)

        sc_vulnerable_count = 0

        for sc_filename in os.listdir(self.vulnerable_contracts_dir):
            sc_name, file_extension = os.path.splitext(os.path.basename(sc_filename))
            sc_path = os.path.join(self.vulnerable_contracts_dir, sc_filename)
            if os.path.isfile(sc_path) and file_extension == ".sol":
                # Create dir for contract
                results_dir =  Path(os.path.join("experiment_results",
                f'{self.experiment_settings["experiment_name"]}_{self.experiment_settings["llm_model"]}'),
                sc_name)
                results_dir.mkdir(parents=True, exist_ok=True)

                # Copy vulnerable sc to results
                sc_results_path = Path(os.path.join(results_dir, sc_filename))
                shutil.copyfile(sc_path, sc_results_path)
                
                # Add to results
                sc_vulnerable_count += 1
                self.smartbugs_sc_queue.put((sc_results_path, True))

        # Initialize progress bar
        n_candidate_patches = self.llm_settings[self.experiment_settings["llm_model"]]["num_candidate_patches"]
        progressbar = tqdm(total=sc_vulnerable_count * n_candidate_patches, desc="Processing items", colour='#ff5a5f')

        stop_event = threading.Event()
        #### Step 2: Consume smartbugs_queue
        for i in range(self.experiment_settings["n_smartbugs_threads"]):
            smartbugs_thread = threading.Thread(target=TransformativeRepair.consumer_of_vulnerabilities_queue, args=(self.experiment_settings, self.smartbugs_sc_queue, self.repair_sc_queue, stop_event, progressbar))
            smartbugs_thread.start()

        #### Step 2: Consume smart repair_sc_queue
        for i in range(self.experiment_settings["n_repair_threads"]):
            repair_thread = threading.Thread(target=TransformativeRepair.consumer_of_repair_queue, args=(self.experiment_settings, self.llm_settings, self.smartbugs_sc_queue, self.repair_sc_queue, stop_event))
            repair_thread.start()

        #### Start Summary Thread
        summary_thread = threading.Thread(target=TransformativeRepair.create_summary, args=(self.experiment_settings, self.llm_settings, stop_event))
        summary_thread.start()


        